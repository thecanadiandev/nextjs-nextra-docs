{"/":{"title":"Intro","data":{"":"These are my notes for the udemy course Next JS & React - The complete guide\nReact is a pre req. Next builds on top of it.\nReact is just a library. Why do we need another library that builds on top of it?\nNext js a fullstack react framework.\nIt simplifies the process of building fullstack apps with react.\nReact itself has added more features like improved SSR, Streaming responses, React Server components, Server actions etc.\nTo build a full stack app, we need Routing, form submission, data fetching, authentication and more.\nNext builds up on react & simplify the process of building full stack web apps with react.","key-features#Key features":"Just with JS, we build both front end and backend.\nsame project itself.\nFile system based Routing, not configuration or packages.\nAll contents (pages & components) visible on screen is rendered on server first and sends a finished page to client helping SEO.\nRun npx create-next-app@latest to scaffold a next app.\n\n\n\n\nWe use App router instead of Page router.\nnavigate to the folder root and run npm run dev","react-vs-next#React vs Next":"If we inspect the page source, we see the actual finished page being sent from the server.\nThe actual content visible on the page was sent from server. This is not the case for a standard client app.\nOn a standard react app, we render a bare minimum frame and then manipulates it in the browser.\nSo react app is just a client side app, whereas next js is both server side & client side in one project.\nWith next, we have a full stack app that blends client & server side.\nin Nextjs, page is a reserved keyword. Similarly, there are a lot of reserved names.\nAnything within the app, is for the routing. If we need to create components, do it inside a components folder which is a sibling to the app folder.","add-pages-by-routes#Add pages by routes":"app/\nawesome/\npage.js // ==> loads localhost:3000/awesome if we export a standard react component\nKeep in mind, it has to be a default export.","2-approaches-for-building-apps#2 approaches for building apps.":"page router vs app router\nboth approaches help build full stack apps.\npages router is the older & stable.\napp router is the newer one. ( NextJS 13+, server components & server actions , modern way, but buggy to an extend, but the future is here)","file-based-routing--server-components#File based routing & Server components":"npm i and the npm run dev to run the app locally.\napp is the most important folder. we sets up different pages within it.\npage.js is a reserved name.\nIt is a server component. They are rendered only on server, never on client.\nThe component function is executed on server only.\nthe console is executed in terminal. If you check dev tools, we won't see it.\nto add more pages, within app folder, we add about/ folder within which we add a page.js.","in-app-navigation#In-app navigation":"For navigation between pages within the app, we use next js link. Regular links refreshes the page.\nWith nextjs, when we visit a page for the first time, it is rendered on server , gets a finished page and we are here.\nBut if we are on a page, and we click around, next allows to stay in a SPA & update UI with help of client side JS code.\nTechnically, the content of the next page will still be pre-rendered on the server but updated on client side with client side JS code.\nWe get the best of both worlds, a highly interactive client side app, a finished page being served if we are visiting the page for first time.\n\n\nimport Link from 'next/link';\n\n<Link href=\"/about\"> About </Link>;\nWith regular anchor element, the page refreshes and we loose the app state.","pages--layout#Pages & layout":"page defines the content of the page\nlayout defines the shell around one or more pages.\nit is the layout into which the page will be rendered.\nevery project needs atleast one root layout.js\nand if we need we can add within the page folders too if we need different layouts for it.\n\n\n// layout.js\n// to import global styles, we can import it here.\n\nimport './globals.css';\n\n// meta is a reserved name\nexport const metadata = {\ntitle: 'NextJS Course App',\ndescription: 'Your first NextJS app!',\n};\n\nexport default function RootLayout({ children }) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n);\n}\n\nicon.png is a special name. It will be used as a favicon if placed directly in the app folder.\nwe can add regular react components too and import them to page.js\nwe could add a components folder too.\nPreferrably , store the components folder outside the app folder. App is used for routing related tasks only.\nUse the @ to point to root.","reserved-names#Reserved names":"page.js      => Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)\nlayout.js    => Create a new layout that wraps sibling and nested pages\nnot-found.js => Fallback page for \"Not Found\" errors (thrown by sibling or nested pages or layouts)\nerror.js     => Fallback page for other errors (thrown by sibling pages or nested pages or layouts)\nloading.js   => Fallback page which is shown whilst sibling or nested pages (or layouts)\nare fetching data\nroute.js     => Allows you to create an API route (i.e., a page which does NOT return JSX code\nbut instead data, e.g., in the JSON format)","dynamic-routes#Dynamic routes":"app/ blog/[slug];\npage.js; // => loads localhost:3000/blog/post-1\npage.js; // => loads localhost:3000/blog\n\nNext js automatically passes a prop object. From which we can pull out the dynamic prop.\n\n\nexport default function BlogPostPage({ params }) {\n// params.id\n}","add-local-images#Add local images":"import logoImg from '@/assets/logo.png';\n\nconst MainHeader = () => {\nreturn (\n<header>\n<Link href=\"/\">\n<img src={logoImg.src} alt=\"food\" />\nNext Level food.\n</Link>\n</header>\n);\n};\nexport default MainHeader;","styling-options#Styling options":"we have global css where we can add multiple styles and import in layout.\ntailwind css is another one\nCSS Modules","using-scoped-styles#Using scoped styles":"import classes from './main-header.module.css';\n\nconst MainHeader = () => {\nreturn (\n<header className={classes.header}>\n<Link className={classes.logo} href=\"/\"></Link>\n</header>\n);\n};\n\nexport default MainHeader;","optimize-images#Optimize images":"optimizes images by making it responsive.\noptimizes the size based on viewport.\nadds extra props like loading=lazy , srcset etc\nserves in best file format (webp) which is more efficient than png.\n\n\nimport Image from 'next/image';\n\nconst MainHeader = () => {\nreturn (\n<header className={classes.header}>\n<Link className={classes.logo} href=\"/\">\n<Image priority src={logoImg} alt=\"food\" />\nNext Level food.\n</Link>\n</header>\n);\n};\n\nexport default MainHeader;","a-note-on-client-components-with-usestate#A note on client components with useState":"whenever we use a component with useState, it wont work in a server component\nSince all components are server components by default, we need to mark it as client explicitly.\n\n\n\nexport default function ImageSlideshow() {\n\nconst [currentImageIndex, setCurrentImageIndex] = useState(0);\n\nuseEffect(() => {\n...\n}, []);\n\nreturn (\n<div className={classes.slideshow}>\n...\n</div>\n);\n}\n\neven if we are on the SPA world once loaded & navigate around, all the components will still be rendered on server & in the end\na finished HTML code that is sent to client to be rendered.","react-server-components-vs-client-components#React server components Vs Client Components":"React Server Components\tClient Components\tOnly rendered on server\tComponents are pre-rendered on server, but also potentially on client\tBy default, all react components are RSCs\tOpt in via \"use client\" directive\tLess client side JS, great for SEO\tLogic resides on client side","link-highlight#Link highlight":"to extract path, we can use the hook \"usePathname\";\n\nto tackle this, we need to add the use client directive.\n'use client';\nimport { usePathname } from 'next/navigation';\n\nconst MainHeader = () => {\nconst path = usePathname();\nreturn (\n<header className={classes.header}>\n<nav className={classes.nav}>\n<ul>\n<li>\n<Link\nhref=\"/meals\"\nclassName={path.startsWith('/meals') ? classes.active : undefined}\n>\n{' '}\nBrowse meals\n</Link>\n</li>\n<li>\n<Link\nhref=\"/community\"\nclassName={path === '/community' ? classes.active : undefined}\n>\n{' '}\nFoodies Community\n</Link>\n</li>\n</ul>\n</nav>\n</header>\n);\n};\n\nexport default MainHeader;\nwhile we can do that, make sure, we add them far down the component tree as possible.\nSo the majority still can be server components & is rendered on server.\nSo for those reasons, easy to create a smaller focused new componentHere, only this lean component is client side rendered. We dont need to mark the parent consuming one as client.\nThereby, it still renders in server, and this one renders on client.\n'use client';\nimport Link from 'next/link';\nimport React from 'react';\nimport { usePathname } from 'next/navigation';\nimport classes from './main-header.module.css';\n\nconst NavLink = ({ href, children }) => {\nconst path = usePathname();\nreturn (\n<Link\nhref={href}\nclassName={path.startsWith(href) ? classes.active : undefined}\n>\n{' '}\n{children}\n</Link>\n);\n};\n\nexport default NavLink;","installing-sqlite3-db#Installing SQLite3 DB":"npm i better-sqlite3\nnode initdb.js\n\n// lib/meals.js\n\nimport sql from 'better-sqlite3'\nconst db = sql(\"meals.db\");\n\nexport async function getMeals() {\nawait new Promise(resolve => setTimeout(resolve, 1000))\nreturn db.prepare('SELECT * FROM meals').all()\n}","fetch-data-using-nextjs--fullstack-capability#Fetch data using Nextjs & fullstack capability":"When fetching data, our initial tendancy is to use the useEffect hook. But with next, since the component runs on server, we can directly reach out to the DB from here. Server components can be async too.\n// this can be a method to fetch the data from the DB\nimport { getMeals } from '@/lib/meals';\n\nconst MealsPage = async () => {\nconst meals = await getMeals();\n\nreturn (\n<>\n...\n<main className={classes.main}>\n<MealsGrid meals={meals} />\n</main>\n</>\n);\n};\n\nexport default MealsPage;\nNext is aggressive w.r.t caching. So if we navigate to another page and come back, next shows us the cached page. We need to manually refresh to see the modified data.","loading-page#Loading page":"the reserved loading.js will become active if the page next to it or nested ones is loading data.\nonce loaded, if we navigate to another page and come back, since next caches the response, the loading is instant.\n\n\nimport classes from './loading.module.css';\n\nexport default function MealsLoading() {\nreturn <p className={classes.loading}> Fetching meals...</p>;\n}\n\nthe problem now is, loading occupies entire screen.","suspense--streamed-response-for-granular-loading#Suspense & Streamed response for granular loading":"Instead of showing a totally different page, we can only show a part of the page\nWe can show some part of the page as static piece, and only load a certain section by showing a fallback message.\nThat way, user sees the page and knows that only some section is loading some data.\nTo do that, offload the lofic into a smaller component, and wrap them with Suspense.\n\n\nasync function Meals() {\n// outsource data fetching part into a component\n// wrap this component with Suspense.\nconst meals = await getMeals();\nreturn <MealsGrid meals={meals} />;\n}\n\nconst MealsPage = () => {\nreturn (\n<>\n...\n<main className={classes.main}>\n{/* only this part is shown loading. */}\n<Suspense\nfallback={<p className={classes.loading}> Fetching meals...</p>}\n>\n<Meals />\n</Suspense>\n</main>\n</>\n);\n};\n\nexport default MealsPage;","handle-errors#Handle errors":"error.js is a reserved file and must be a client component.\nIt should be able to catch errors that happen in client side too.\n\n\n// to simulate it,  in lib, throw an error..\n\nexport async function getMeals() {\nawait new Promise((resolve) => setTimeout(resolve, 1000));\nthrow new Error('testing error...');\n}\n// in meals/error.js\n\n('use client');\n\n// will only handle errors that sits in the same folder\n// or nested page or layout\n// can add it to root level, or on a folder basis.\n\nconst ErrorPage = ({ error }) => {\nreturn (\n<main className=\"error\">\n<h1> An error occured.. </h1>\n<p> Failed to fetch.. </p>\n</main>\n);\n};\n\nexport default ErrorPage;","not-found-states#Not found states":"we can have default 404 pages\nadd a not-found.js anywhere in app folder and will cover siblings and nested pages.","dynamic-routes-and-route-params#Dynamic routes and route params":"import React from 'react';\n\nconst NotFound = () => {\nreturn (\n<main className=\"not-found\">\n<h1> Meal Not found</h1>\n<p> Seems something inst right.</p>\n</main>\n);\n};\n\nexport default NotFound;","load--render-details-with-dynamic-routes#Load & render details with dynamic routes":"// lib/meals\n\n// the below syntax is SQLite db specific.\n// Below syntax helps against cross site scripting atatcks\n\nexport function getMeal(slug) {\nreturn db.prepare('SELECT * from meals WHERE slug = ?').get(slug);\n}\n\n// MealDetailPage\n\n// all pages gets a params prop passes into it.\n\nimport { getMeal } from '@/lib/meals';\nimport { notFound } from 'next/navigation';\n\n// receives params prop.\nconst MealDetailsPage = ({ params }) => {\nconst meal = getMeal(params.mealSlug);\nif (!meal) {\n// shows the closest not-found page\nnotFound();\n}\n\n// instruction is a string text here as content is a string HTML\nmeal.instructions = meal.instructions.replace(/\\n/g, '<br/>');\nreturn (\n<div>\n<header className={classes.header}>\n<div className={classes.image}>\n<Image fill src={meal.image} alt={meal.title} />\n</div>\n...\n</header>\n<main>\n<p\nclassName={classes.instructions}\ndangerouslySetInnerHTML={{\n__html: meal.instructions,\n}}\n></p>\n</main>\n</div>\n);\n};\n\nexport default MealDetailsPage;","image-picker-logic#Image picker logic":"'use client';\n\nimport { useRef, useState } from 'react';\nimport classes from './image-picker.module.css';\nimport Image from 'next/image';\n\nexport default function ImagePicker({ label, name }) {\nconst [picked, setPicked] = useState();\nconst imageInput = useRef();\n\nfunction handleClick() {\nimageInput.current.click();\n}\n\nfunction handleImageChange(event) {\nconst file = event.target.files[0];\nif (!file) {\nsetPicked(null);\nreturn;\n}\n// data url for preview\nconst fileReader = new FileReader();\nfileReader.onload = () => {\nsetPicked(fileReader.result);\n};\nfileReader.readAsDataURL(file);\n}\nreturn (\n<div className={classes.picker}>\n<label htmlFor={name}> {label} </label>\n<div className={classes.controls}>\n<div className={classes.preview}>\n{!picked && <p> No image picked yet</p>}\n{picked && <Image src={picked} alt=\"Image selected by user\" fill />}\n</div>\n<input\nclassName={classes.input}\ntype=\"file\"\nid={name}\naccept=\"image/png, image/jpeg\"\nname={name}\nref={imageInput}\nrequired\nonChange={handleImageChange}\n/>\n<button onClick={handleClick} className={classes.button} type=\"button\">\n{' '}\nPick an image{' '}\n</button>\n</div>\n</div>\n);\n}"}},"/ngrx":{"title":"Ngrx","data":{"":"State management system / library\n3rd party library created by same team\nA package, that helps manage app wide state\nComplex apps.\nState changes over time\nInstead of managing state in components & services, we manage them outside of them.\nClearly defined approach to manage state\nStore is a centralized virtual javascript object, where data is stored & managed. Component reads data from store & can listen to changes in store.\nSelectors can help get respective slices for component\nTo change data, dispatch actions to store which is picked up by reducer who mutates state for the store.\nEffects are side effects ( anything async is handled here, like HTTP requests )","install-ngrx#Install ngrx":"ng add @ngrx/store  // downloads, installs & updates the module\n\nExample","selectors#Selectors":"Example","book-example#Book example":"Example","effects#Effects":"side effects\nanything that is not directly related to Ui update\navoid them in reducers, which should be pure.\nng add @ngrx/effects\n\nFull fledged example in Github"}},"/install":{"title":"Installation","data":{"":"to create project, we do not build from scratch.\nwe rely on a build tool that converts typescript to javascript, Scss compilers, build optimizations,\ncompress the code, minify, uglify, the code.\ncli helps the process of building angular apps.\nInstallation docs\n\n\nnpm install -g @angular/cli\nIf using mac, you may need to use sudo at the start\nIf you are within a office/corporate environment, you may need admin rights to do the same.\nCheatsheet","need-for-a-cli#Need for a CLI":"Why cli? The source code is build, Typescript is compiled to javascript and spins up a dev server. Double clicking index.html and opening up will only have a file protocol and we need a lot of dynamic compiling and we need to simulate how it looks in a real app only if we have the http protocol. For those, we need cli tooling, which does the heavy lifting. CLI does optimizations behind scenes to give a bundle for respective environments.","to-create-an-angular-application#To create an angular application":"ng new my-app-name\n\nIt will ask the following questions\nAdd routing? : No\nStylesheet   : css/Less/Sass/Scss\nSSR / SSG?   : No\n\nOnce the installation is done, cd into the folder & run the app by the command ng serve and the application will be\nup and running in port 4200 by default.","extensions#Extensions":"Angular language service\nAngular essentials by John papa.\n\nIn terminal\n\nThe bundle values which we see changes depending on when you are seeing this.\nAs angular is iteratively improved, optimizations provided will keep the bundle sizes even smaller.Open the browser under this url\nhttp://localhost:4200/\nThe home page will look something like this. It may change depending on when you see this though.\n\nIf you open the \"View Page Source\", it should look something like this\n\nwhich if you wonder, doesnt look like the screenshot you saw as the landing page.\nThis is what SPA does. The initial load just bring in this much only, and the whole application is rendered within <app-root></app-root> tag which you see above. See the explanation of the same in the next section."}},"/folder-structure-walkthrough":{"title":"Folder Structure walkthrough","data":{"":"","how-is-the-application-getting-bootstrapped---#How is the application getting bootstrapped? ( 📚 )":"Angular.json is the heart of the application\nIn angular.json, look at this portion\n\"root\": \"\",\n\"sourceRoot\": \"src\", // 👈 means, the application source is held within this folder\n\"prefix\": \"app\", // 👈 means, the components will be prefixed with this word (app-root, app-header etc)\n\"architect\": {\n\"build\": {\n\"options\": {\n\"index\": \"src/index.html\", // 👈 the only HTML sent across from server\n\"main\": \"src/main.ts\", // 👈 the first file compiler should look for.\n\"assets\": [\n\"src/favicon.ico\",\n\"src/assets\"\n],\n\"styles\": [\n\"src/styles.scss\" // 👈  custom styles which are imported dynamically in head as a link tag\n],\n\"scripts\": [] // 👈  extra javascript to be dynamically injected as a script tag\nand within the index.html, we have a placeholder. The whole application will be rendered inside this placeholder div\n<body>\n<app-root></app-root>  // 👈 whole app rendered inside this component\n</body>\n\n\nSPA flow,\nbrowser sends an initial request to server\nit responds with a minumum set of HTML, JS and css\nPage renders with that shell\nJS takes control\nThen it renders the app within the placeholder, creates and swaps components to simulate page changes\nmakes api calls to get the respective data in JSON format to feed the components with data.\n\nwithin this placeholder, whatever module the main points to, ( src/main.ts )the main.ts points to the AppModule\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\n\nplatformBrowserDynamic()\n.bootstrapModule(AppModule)\n.catch((err) => console.error(err));\nAngular has the concept of modules. ( which is a nice way of encapsulating functionalities into smaller focused bundles which can be brought into the application based on our requirements. ).The syntax above basically says, platformBrowserDynamic is a module that helps us take our application which is wrapped within the AppModule to loaded into browser. This step is done via platformBrowserDynamic and not directly injected into DOM like a jquery or javascript using document.querySelector or anything. That is because we need to make the application loosely coupled so that it can be plugged into browser as well as non browser environments. ( like Ionic which is used for building native mobile apps ). For such situation, instead of platformBrowserDynamic, we use the mobile equivalent method platformNativeScriptDynamic so that the bootstrapping is done right and there is no direct DOM dependency. We need our application to work on all environments ( browser, server, web worker, mobile device etc ).An angular application should contain atleast one module and within that one component ( With Angular 16, we have stand alone components which omits the use of modules though - More on that later )","what-about-modules#What about modules?":"Think of modules like a basket. Instead of dumping all the fruits in one basket, we divide them into respective baskets and put them within. Apples in one basket, oranges in other. Similarly, we can divide the application into respective dedicated modules. Each module is like a gated wall. Whatever gets registered within this module can be used within this module. To use them at some other modules, we need to explicitly export them.Not all the logic is stuffed into one single module. Instead, they are divided into smaller modules each having their own specific functionality. To unlock the functionality, we need to register the module. ( eg: Forms, HTTP, Animations )An AppModule looks like this.\n@NgModule({\ndeclarations: [AppComponent], // 👈 register components, pipes, directives here\nimports: [BrowserModule, AppRoutingModule], // 👈 other modules are registered here\nproviders: [], // 👈 services are registered here\nbootstrap: [AppComponent], // 👈 root component of the application\nexports: [] // 👈 Things that need to be exported from this module to another.\n})\nexport class AppModule {}\nNote: providers: [] is not as simple as it is, more on it later.Here, we see something called a @NgModule which is a decorator.This is a typescript concept.A class can be decorated with various decorators. Here since its decorated with @NgModule we are asking the angular compiler to identify the class as a Module and we also pass some configuration into it. Similar to NgModule, we have @Component, @Directive, @Pipe, @Injectable etc,The bootstrap property points to the root component which is AppComponent ( Note that this is not css bootstrap and has nothing to do with it. Don't get confused. This basically means glue the component to the module as the first component in the tree ). Angular is asking, \"where should I start creating the component tree from?\"Basically, our application is a bunch of components nested within one another and represents more or less like a tree, for which, we need a root, and that root is AppComponentif you remove the AppComponent from the bootstrap property, keep the array empty and see the browser, we see it empty. Check the console and see those error\nERROR Error: NG0403: The module AppModule was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. Please define one of these.\nbasically, the error screams that the root component is missing.","wiring-up-explained#Wiring up explained.":"The index.html is the only page that is served. There are dynamic scripts being injected in index.html of the served page, by cli automatically. These bundles are added automatically by the framework. The flow is angular.json -> main.ts -> starts / bootstraps the angular app by passing a module to this method. In app module, we registered the app.component as the bootstrap property. This is the first component that needs to be loaded. Angular framework changes the DOM at runtime.","what-is-a-component#What is a component":"if you open up app.component.ts\n@Component({\nselector: 'app-root',\ntemplateUrl: './app.component.html',\nstyleUrls: ['./app.component.scss'],\n})\nexport class AppComponent {\ntitle = 'test';\n}\nwe see something similar to what we have seen before. A regular typescript class, but this time decorated with @Component. Decorators add metadata to make angular understand what it is and how it should process it. The decorator informs angular that, please consider this class as a component. We will use this component with the custom tag of <app-root></app-root> ( in index.html)Every component will be having 3 pieces\nTemplate logic ( within HTML)\nBusiness logic ( within the class file , ie .ts file)\nStyling ( within the .css / .scss file)\n\nThe style that is mentioned in the css will be scoped to that component by default. ( More on that later)A variation of the component can be like this with inline template & inline styles.which one to choose is a personal choice. From angular's perspective, there is no advantage of using one over the other.The one point that we can argue is that, if we use the array syntax for styles, then we can have multiple style files tacked on if we wish.\nstyleUrls: ['style1.scss', 'style2.scss'],\nThe above is not common, but possible. This may need additional webpack configuration tweaks.Read more here","component-selector#Component Selector":"A component selector can be an element, an attribute, a class but not a ID\n@Component({\nselector: 'app-header', //by element\nselector: '[app-header]', // by attribute\nselector: '.app-header', // by class\ntemplateUrl: './header.component.html',\nstyleUrls: ['./header.component.css']\n})\n\nNote: just because we created a component doesn't mean angular will magically recognize them.\nFor that, we need to register them within the module inside the declarations array\n@NgModule({\ndeclarations: [  AppComponent ], // 👈 register the component\nUnless a component is registered within a module, angular won't be able to recognize them as component & identify its custom selector anywhere within the module where we try to use them as components. If we dont register the component, it says that the custom selector we used is something that angular didnt understand.The .spec file is for unit testing purpose.","standalone-components#Standalone components":"Note that module based architecture was the default way of building the application till Angular 15, but when stand alone components was released,\nwe got a new way of building apps without modules. Concept wise, the fundamentals all remain as is, the difference being, instead of modules being used as containers, the idea is somewhat different.Example Angular 17 stand alone appThe standalone flag + imports array combo helps us register stand alone components."}},"/component-composition":{"title":"Component Composition","data":{"":"In angular, or rather any framework that uses component based architecture,\nWe no longer see a page as a page, but we see tham as a bunch of re-usable components.\nSee the image below. We divide the page as a bunch of (nested) componentsThat's where the idea of composition comes into the picture.","you-think-about#You think about":"making the leanest possible component,\nhow can you customize them,\nwhat all inputs can be passed, what all outputs need to be provided\nhow will component communicate with each other.\nconfigure them,\nreuse them\ntest them\n\nThat's what Single responsibility principle says. A component should ideally do just one thing, and one thing only. If it does more than one thing, then better split them into another component.","modules#Modules":"In angular, modules are basically wrappers that bundle the application into small packages. Note, there is something called typescript module too, which is not what i mean when i say \"module\" here in this context.Module becomes more important when we discuss about lazy loading towards the end where we discuss about optimizations. For better loading times, we keep the main app module lean, and thin, and via routing, we load subsequent portions of the application upon clicking the link which then loads its code as a small chunk ( ie bundle of js which is a small file which you can see in the Inspect / Network section ) and navigates to that part of the application.When the app grows, it becomes important to split them into meaningful modules so that we bundle the logic within respective modules and load them on demand. Don't just keep stuffing the app module with more and more logic. That hampers loading time, performance & affects scalability & maintainability.The whole angular functionalities has been split between various modules.\nIf you take a look at the package.json, we see many package dependencies. Each package holds certain logic which we use it via registering them within the imports: [] of the module when needed.\n\"dependencies\": {\n\"@angular/animations\": \"^15.0.0\", // 👈  all animation logic is within this module\n\"@angular/common\": \"^15.0.0\", // 👈  common component logic is here\n\"@angular/compiler\": \"^15.0.0\",\n\"@angular/core\": \"^15.0.0\", // 👈  core angular functionality here\n\"@angular/forms\": \"^15.0.0\", // 👈  forms related logic here\n\"@angular/platform-browser\": \"^15.0.0\",\n\"@angular/platform-browser-dynamic\": \"^15.0.0\",\n\"@angular/router\": \"^15.0.0\",// 👈  routing logic here","adding-a-new-component#Adding a new component":"I use stackblitz for live code so that you get to see live previews of whatever we are learning.\nThis helps you from jumping into other IDEs, having npm install issues, \"works in yours but not mine\" issues etc. If you want to code along in an editor, feel free to do so. I dont want anyone to miss out on the code. Hence using stackblitz as an embed.Styling is done using bootstrap 5. Note that styling isnt our priority.\nSo, the point is explaning a concept in the least amount of code so that you get to understand the fundamentals and concepts within.if you like to open the stackblitz editor in a separate browser,\nHello world Example here.\nYou may need to login with google/github account though.\nMake sure you fork the code before working on it.","here-is-a-small-task#Here is a small task":"Try creating a banner component.\nRegister the component and use them to show the component within the App Component.\nPlay around and see what happens if you forget to register the component within the module.\nGo through the flow and see if you can wrap the head around the concept & flow.\n\nSolution hereQuestion: What happens when we use the component instance twice?\n<app-banner> </app-banner>\n<app-banner> </app-banner>\nUnderstand that, each component instance is different. State is confined to that instance. If we use the component twice, each has its own state slice.","explanation#Explanation":"In stackblitz, on the file explorer, if we right click, we get a menu called \"Angular Generator\" which helps to scaffold components, modules, services, directives, pipes etc. If you use VS code, there is an equivalent extension called \"Angular Schematics\". Other 2 VS code extensions worth recommending is Angular Essentials from John Papa, and Angular Language Service along with Prettier.\nIf you are a fan of command line, then there is a cheat sheet which i found online hereAs of now, there is nothing dynamic. The HTML of banner is just a static piece. We will bring interactivity into it. The HTML inside of the component contains few bootstrap classes for styling. That's all. Try to track the wiring up of the component in your mind. As we move forward, we will see more complex and advanced concepts. So start preparing for that now.Note: we dont need the .ts extension when we import. That is added automatically by webpack.\nimport { BannerComponent } from './banner/banner.component'; // 👈  no .ts extension here\n\n@NgModule({\ndeclarations: [ BannerComponent],\nbootstrap: [AppComponent],\n})","is-template-a-must-for-a-component-#Is template a must for a component? (📚)":"Yes, it is. A component is also a directive, but it should have a template.\nBut what exactly is a directive? We will see in detail when we discuss about directive.\nBasically, directives are instructions in DOM. It can be showing or hiding parts of the DOM, it can be adding or removing classes or attributes. Anything that involves accessing DOM, think of directives.\n<div> div </div> is an instruction to the browser to create and render a divider element.\nSimilarly, `<app-banner> </app-banner/>` is an instruction which is understood to angular compiler\nto create and render a banner component","styling--templates--inline--regular-ones-#Styling & Templates ( Inline & regular ones )":"@Component({\ntemplateUrl: '',\ntemplate:`<h1> test </h1>`, // inline\nstyleUrls: ['./app.component.css'],\n// inline\nstyles: [`\nh3 { color: blue }\n`]\n})\nExample here.\nHere, we used only the class file, and used the inline versions of template and styles.","creating-and-registering-a-new-component#Creating and registering a new component":"Example code\nMake sure, standalone is true.\nWe also have module based components. ( older module based approach )\nimports + standalone works together.\nIt adds the components to the tree.","add-images-to-the-application#Add images to the application":"In src/ we created an assets folder.\nInside that, we have a logo.png\nwhen loading an image like this from assets folder, we need to tweak:\nIn angular.json,\n\n\n// inside build node,\n\"assets\": [\n\"src/favicon.ico\",\n\"src/assets\"// add this\n]\n\n// or if its an object\n\"assets\": [\n\"src/assets\", // add it here.\n{\n\"glob\": \"**/*\",\n\"input\": \"public\"\n}\n]\n\n// and in template , we can target assets folder like this.\n\n<img src=\"assets/logo.png\"/>"}},"/standalone":{"title":"Standalone Components","data":{"":"Idea is to work without modules.\nIntroduced in Angular 14+\nIts introduced in Preview mode for V14. So the syntax can change later. With V15, its stable.\nThat doesnt mean, we should use this in production ready apps.\nStandard apps have one problem - Boilerplate code.\nIt makes refactoring painful.\nAngular modules help organize & structure the code, but it comes with its own boilerplates.\nTo get rid of ngModules, angular brought Standalone modules.\n\nExampleThe new mode ( in preview ) can be mixed with old way.\nIn a regular component, add special flag standalone: true to the configuration of component.\nIf we mark a component as standalone, then do not register the component in any modules.\nWe must still let angular know of this component.\nGo to the component where this component is used, add imports: [DetailsComponent]\nor go to the AppModule, instead of adding the stand alone components to declarations, we add it to imports.\nStandAlone directive is possible. ( standalone: true )\nIn stand alone component, we can add imports: [SharedModule]\nIn AppComponent, if we add standalone to true, which is the root component,  we need to change the main.ts to point to the component.\n\n\n// platform browser\nbootstrapApplication(AppComponent, {\nproviders: [\n// AnalyticsService,\nimportProvidersFrom(AppRoutingModule)\n],\n\n})\nServices:\nWe have providedIn root set to service. If not, we can add a providers: [] within component decorator. But we wont get same instance then.\nRegister the services within the bootstrapApplication as above if we have not used providedIn root.\n\nRouting :\nWe need to let application / app component know about router module.\nimports: [RouterModule] within the component configuration, also, RoutingModule needs to be registered.\nWe add lazy loading as well.\n\nExampleRight now, this is just an alternative. Angular has not highlighted this as the default recommended way."}},"/bindings":{"title":"Component Bindings","data":{"":"We have 4 types of bindingsBy binding, we mean, a connection or a communication between template, which is the HTML  & class / business logic, which is the Typescript logic.\nString interpolation. ( if we have any expression that can result in a string, use this )\nProperty binding (HTML element attributes / properties like alt, src, href , etc can be bound dynamically, or [innerHTML]=\"expression\")\nEvent Binding ( click, keyboard events, mouseevents )\n2 Way binding ( for which we need FormsModule with [(ngModel)] or \"banana in a box syntax\")","note#Note:":"String interpolation and property binding is from the class to the template. ie, (one way binding).\nEvent binding is when user interacts with template which updates the class . (This is also one way binding, but opposite direction )\nTwo way binding is, as the name suggests , bi-directional ( also called Banana in a box )\n$event is a reserved keyword that passes the event data as a parameter when triggering event bindings.\nBy default, event.target.value returns a string. It is not angular related, but javascript specific.\nBindings Example here\nAngular 18 version here\nNote: To get this 2 way binding feature, make sure, we need to register the FormsModule which we have imported from respective namespaces.\nlike this:\n\n\nimport { FormsModule } from '@angular/forms';\n\n@NgModule({\nimports: [FormsModule],\n})\n\nby registering the same within imports:[] array, we unlock all the features provided by the forms module.\nWith standalone, we register them within the imports array of components. Not modules.\nwe also made the button dynamically disabled using the property binding\nso whenever the description is empty, the Accept button is disabled.","another-option--variation-for-ngmodel#Another option / variation for [(ngModel)]":"Example here\nThe only difference is that, we bind to the input event of textarea and the value property.\n$event is a reserved keyword that passes the whole event object into the handler method\nso every time, we type in a new character, it is kept in sync by assigning the target value to the option object's description property.","adding-a-custom-component--v18-#Adding a custom component ( v18 )":"Example here\nHere, we saw the Input and Output flow as well."}},"/directives-component-communication":{"title":"Directives & Component Communication","data":{"":"They are instructions placed in DOM. For example, components.\nDirectives doesn't have a template as components do\nUnlike jquery or javascript, we never do direct DOM changes.\nInstead, we delegate that task to directives which is managed by angular.","they-are-of-2-types#They are of 2 types":"Structural Directives\nthey changes the structure of the DOM.\nSo with this, we can conditionally, add or remove items from DOM\nthey are denoted using an asterik.\n*ngFor, *ngIf are the most common structural directives\n*ngFor allows us to iterate through collections\n*ngIf allows us to show / hide elements conditionally\n\n\nAttribute directives\nThey change the attributes of the element which they are placed on\n[ngClass] to add/remove classes,\n[ngStyle] to conditionally add styles,\n[ngSwitch] to have our traditional switch cases\n\n\n\nExample here","we-can-also-show-ifelse-clauses#We can also show if/else clauses":"<p *ngIf=\"isAdult\"; else minor> Senior</p>\n\n<ng-template #minor>\nMinor\n</ng-template>\nExample here\nHere we say, if the expression evaluates to true, show the main content,\nelse whatever we held within the <ng-template is shown. By default the ng-template is not rendered in the DOM\nWe mark the template with something called a \"TemplateRef\" which is #notawesome here ( think of it as putting an ID in jQuery)\nSimply put, we grab an element reference in the template.","index-for-looping#Index for looping":"*ngFor=\"let item of items; let idx = index\"\nThis basically gives access to the current index of the iteration.","component-communication--parent-to-child-#Component Communication ( parent to child )":"Just like we have built in properties for elements like src, alt etc, and default events like click, enter etc,\nWe can have custom properties and events too which helps components to communicate.Drawn with excalidraw.\n\nAlways keep in mind, data flows down, events flow up. Why? Think of it like a one way traffic where we know the vehicle can only go on certain direction.\nIt helps to track the data and narrow down to the components and is easier to reason the app.Example here\nsimply put, the child accepts input via @Input()\nchild emits events back to its parent via @Output()\nEventEmitter<any>() is a generic type helps us to emit our own events in angular.\nonSelect is a custom event. Just like regular click, mouse, keyboard events, we create our own custom event here.","question-time#Question time":"if we have a chain of components where there are 4 levels, is it okay if we pass the data from parent to the deeply nested child as props?\nWhat are the drawbacks?","example-time--putting-everything-we-have-learned-till-now#Example time ( Putting everything we have learned till now)":"This time, we are taking all the knowledge we learned till now and build something small.\nGo through the code and see if you can track them & understand. Dont freak out! It is easy.\nWe also learn the basics of component communication here.\nBelow is a collection of users.\nwe Iterate through the collection using ngFor\nHave 2 components - A UsersComponent (parent) & UserComponent ( child )\nWe register both in the app module and use the selectors.\nwe communicate between components.\nour aim is to make lean & focused components. We have a smart-dumb combo here where, parent holds the logic, and pass it down to child. Some call it \"Container-Presentation\" approach too.\nParent component is just a wrapper ( holding the logic )\nIndividual user is shown within child component ( accepts input & sends back output )\nPass data down using @Input which is a part of component communication\nPass selected user up to the immediate parent using @Output and EventEmitter\nwe conditionally show a \"fresher message\" if user is fresher with *ngIf\nwe do interpolation & attribute binding like we learned before.\nwe use a switch statement to tell more about skill rating with [ngSwitch]\nwe define an interface / model to define how a user should look like.\nwe use ngStyle to change cursor styles inline\nClick on the button and check console.\nUse bootstrap Card to display user details\n\n\n\nStackblitz code","explanation#Explanation":"Here, we are having a custom property called user for the UserComponent to which we pass a user instance down from the parent & a custom event OnSelect\nThe property binding and event binding is used here too, just that on our own properties and events\n\n\n<app-user\n(onSelect)=\"handleSelect($event)\" // 👈  binding to a custom event\n[user]=\"user\"> // 👈  binding to a custom property\n</app-user>\n\nwe have an onSelect which is an EventEmitter which emits the event to the immediate parent.\nIn a uni-directional pattern, data flows down, events flow up.\nSo long as the logic is handled by parent, child just need to obey what it is told to do.\nthe decision making is delegated to parent. We pass a user down, and when the user is selected, we emit that up.\nWhat parent does with that info is not child's concern. It can log the value, add it to collection, or show a notification. Whatever it is.\nIt makes testing much easier.","additional-notes#Additional notes":"There is a concept called \"alias\"ing where we can alias the input and output.\nReason: You created an input & ouput and when expose, you realize that some other developer too has used the same name for inputs and outputs, or the project style guide recommends another pattern. So when we expose them outside, we use a different name, but logics within are in tact.\n\n\nexport class UserComponent {\n@Input('myUser') user: User;\n@Output('customSelect') onSelect = new EventEmitter<User>();\n}\ninstead of this\n<app-user\n(onSelect)=\"handleSelect($event)\"\n[user]=\"user\">\n</app-user>\nwe need to use them as below for it to work once we apply aliases\n<app-user\n(customSelect)=\"handleSelect($event)\"\n[myUser]=\"user\">\n</app-user>"}},"/view-encapsulation":{"title":"View Encapsulation","data":{"":"Usually, the styles which we write for a component should be scoped to it.\nWith ViewEncapsulation, we can choose the component styles to be scoped to itself, or make it bleed out.In styles.css\np {\ncolor: blue;\n}\n\nWe have added a style for paragraph within our card component\np {\ncolor: red;\n}\nStackblitz code","explanation#Explanation":"What we see now is, the inner paragraph within the card is red, outer one is blue.\n\nIf inspecting the inner paragraph in dev tools,\np[_ngcontent-vaq-c44] {\ncolor: red;\n}\nthe selector changed. Angular has added a random attribute making it more specific. This is intentional.\nA component shields itself from outside styles so as they are not accidentally overwritten.if we put\nimport { ViewEncapsulation } from '@angular/core';\n\n@Component({\nselector: 'app-card',\ntemplateUrl: './card.component.html',\nstyleUrls: ['./card.component.css'],\nencapsulation: ViewEncapsulation.None,\n})\nthen both paragraphs will be red. here we say, we dont need any encapsulation.\nIt is okay that the style overwrites global styles or vice versa.Other options are\nEmulated ( default ) - Angular modifies the component's CSS selectors so that they are only applied to the component's view and do not affect other elements in the application, emulating Shadow DOM behavior. Styles are added to the head of the document.\nNone ( styles added to head and will globally affect any matching elements )\nShadowDom a.k.a Native ( works only if browsers has built in support for it. So emulated is the recommended default). Styles are only added to the shadow DOM host","what-is-a-shadow-dom#What is a shadow DOM":"Think of it as a DOM within a DOM, but specific to that element.\nThink of it as an island within which there are smaller isolated areas of land.\nThe component's view is enclosed within ShadowRoot, and the styles are isolated to that portion of DOM\nThink of a small region within the whole DOM within which the component's view is embedded. Whatever styles the component has, is only active within that specific area."}},"/essentials":{"title":"Angular essentials","data":{"":"core concepts\nproject structure\ncomponents\nTS & declarative code\nhandle events\nrendering & updating dynamic UI content","folder-structure-walkthrough#Folder structure walkthrough":"may change depending on when we install them\nbootstrapping flow\nwhy is index.html almost empty?\nwhy is it different from what we see when app runs?\nwhat is decorators and how does it affect a class?\nwhat is a selector?\nwhat is the app root and how does it render the application?\nmain.ts is the starting point, how is that connected to angular json file?","stackblitz-hello-world#Stackblitz hello world":"here, i added bootswatch theme instead of bootstrap.\nBootstrap\nBootswatch\n\nCode example","component#Component":"is a combination of 3 things\nHTML, CSS, Logic\nis a class decorated with a \"decorator\"\n\nAdd a custom navbar component\nExplain more about the decorator configuration.\nwhy dashed selector names ?\ntemplate or url, & also styles or styleUrls\nstyling is scoped to the component\nstandalone component is just one of the many ways of having components. (current)\nModule based components is another one (past)\n\nProducts & Banner components","add-images#Add images":"inside src, have an assets folder,\nangular.json, within build -> assets array, have src/assets entry.","bindings#Bindings":"Below example, we see 3 bindings.\nString interpolation, property binding, event binding.\nThere is one more binding - 2 way binding\nProperty binding targets the underlying DOM object property. It needs to target properties, and not attributes.\n[attr.aria-valuenow]=\"myVal\" if we need to do attribute binding.\nBy adding attr in front of the attribute name you want to bind dynamically, you're \"telling\" Angular that it shouldn't try to find a property with the specified name but instead bind the respective attribute.\n\nExample code","getter-properties#Getter properties":"here, we get to define a getter method, but use as a property in the template.\nExample code","manage-component-state#Manage component state":"we just need to change the state and component re-renders automatically.\n\nExample code","change-detection#Change detection":"automiatically does that with zone js\npart of the framework & can automatically detect user events that could occur in the app.\neg: timers, asynchronous things like api call, user events like click etc","signals#Signals":"a new way of change detection which are special kind of values that tell angular when they changes.\nolder way was using zone js\nsupport since Angular 16\nwith signals, it notifies angular about value changes and needing UI updates\nwe create a container & when its changed, angular is notified and can identify all the places in template where the value is used, and can update these places.\nAngular manages subscriptions to the signal to get notified about value changes.\nto extract value from a signal, we need to execute them.\nZone js is a mechanism where, small zones are created in the app , which is just invisible groupings setup behind scenes & listens for\nall kinds of events that could trigger state changes and when it happens, angular checks all components in that zone to check for data changes\nwhen using signals, angular sets up subscriptions behind scenes. When invoking the signal in template, it knows to change when the signal value is updated.\n\nSignals & computed example","reusable-components#Reusable components":"we dont always keep values within the component.\nwe pass them as inputs too.\nwe setup models / interfaces to define the contract.\nwe made inputs mandatory\n\nInput /Output example without signalsInput / Output with signals\ncomputed signals are read only ones.\nwe cannot use set/update to change the values set.","signals-vs-decorator-based-inputs#Signals vs decorator based inputs":"when working with signals, angular manages the behind scenes subscription to the signal and get notified about changes\nwhen a change occurs, angular updates the part of UI that needs updating\nso if we are in a project that uses only signals, we need to know the approach\nolder ones may still run on decorator inputs\nwe could call asReadonly() to make a signal read only so that we dont need to make them computed.\n\nReusable button component","enums-and-routing#Enums and Routing":"enums can help us define certain types with values\nRouting is something where we conditionally show/hide elements\nWhen we implement actual routing, we see a totally different way to do this.\nRight now, we use an if clause to show or hide a component.\n\nEnums and Fake Routing example","outputting-list#Outputting list":"we can loop over collections.\nThe @for, @if came by angular 17 only.\nprior to that we had *ngFor, *ngIf structural directives. For fallback, we use ng-template\n\nCode exampleFiltering example","conditional-classes#Conditional classes":"ngClass is one option.\nother option is the below one.\n\n\n<button [class.active]=\"isSelected\"> </button>","two-way-binding#Two way binding":"here we add the forms module and register them within the imports to unlock the features.\nwe learn about ngModel banana in a box syntax\nstate lifting & refactoring\ndo not invoke the signals within 2 way binding. Just pass the reference as is.\nFormsModule includes a component called \"form\" as a selector & listens to form submission.\n\nCode example","content-projection#Content Projection":"when creating composable components, we make use of slot projection\nwe can have named slot too.\n\nModal with slot projection","template-transformation-with-pipes#Template transformation with pipes":"date, uppercase, lowercase, etc\nDocs\n\nCode example","service--dependency-injection#Service & Dependency Injection":"inject is an alternative to constructor based injection.\nCode example\nwe can use localStorage for data persistance locally.","working-with-modules#Working with modules":"standalone is the new way . but module based approach was the first approach.\nwe register the components, directives, pipes, services etc within the modules.\nanything registered within the modules is made accessible within.\nanything registered in exports array can be used by the consuming modules.\ncomponents need not be registered on a per component level when using standalone.\nbootstrap flow also is slightly different with main.ts pointing to the AppModule\nimports array can be used for standalone components registration. Those cannot be registered in the declarations array.\nshared modules is another concept.\nBrowserModule is meant for root module, for rest, we have CommonModule.\n\nExample code","debugging#Debugging":"angular dev tools.\nsource maps"}},"/deep-dive":{"title":"Deep dive concepts","data":{"":"When should we divide the components into smaller ones?\nSingle responsibility principle.\nDRY ( do not repeat yourselves )\nSeperation of concerns.\nbuild reusable building block.\ninput function is available for 17.1+ only.","extending-built-in-elements#Extending built in elements":"our custom components do end up in DOM.\nso there will be redundant unnecessary elements along with the real DOM elements.\nfor leaner dom, we can extend built in elements.\n\nCode example","multi-slot-projection#Multi slot projection":"here, we dont need to use the class as the selector, but use the ngProjectAs to define a selector which can be used within the ng-content slot which the select property points to.\nCode example\nto restrict to certain contents for projection set the same on select, select=\"input, textarea\"","view-encapsulation#View encapsulation":"every component has a host element, which is what targetted by the selector property.\nwe dont need to add container elements just to add styles on to it for layout purposes.\nhost styles wont work with encapsulation None.\n<app-button class=\"myClass\" is possible and the target .myClass inside stylesheets\nwe can add any attribute of our choice to custom elements.\n\nView encapsulation exampleComponents with host\nexport class ButtonComponent {\n// Discouraged to sue it now. Only for backward compatibility.\n@HostBinding('class') className = 'controls';\n}\nand to use host listener, either uncomment the code, or use the older approach of HostListener.\n@Component({\nhost: {\n// '(click)': 'handleClick()',\n},\n})\nexport class ButtonComponent {\n@HostBinding('class') className = 'controls';\n@HostListener('click') onClick() {\nconsole.log('clicked');\n}\n// handleClick() {\n//   console.log('clicked');\n// }\n}","for-programmatic-access-to-host#For programmatic access to host":"Example code\nTo add classes dynamically, we have multiple syntaxes.\nwe can also bind styles dynamically.","component-lifecycle#Component lifecycle.":"we have constructor, ngOnInit, and much more.\nimplement the interfaces to avoid typos.\nonChanges, afterViewInit, afterContentInit etc are more.\ncleanup with ngOnDestroy. This is the place where we cleanup subscriptions.\nwe can also use DestroyRef to do it.\n\n\n// no need of destroy life cycle\n// available with new angular versions only.\n\nprivate destroyRef = inject(DestroyRef) // from core.\n\nngOnInit() {\nconst interval = setInterval(() => {})\nthis.destroyRef.onDestroy(() => {\nclearInterval(interval)\n})\n}","template-variables#Template variables":"Code example\nIf we apply templateRef on ann element where there is a component selector applied, we get that component instance.\nbecause angualr takes control over it and inherits the underlying element.\n\nViewChild example\nviewChild function, contentChild, viewChildren, contentChildren functions are available too.\nviewChild allows to grab elements which are part of the template.\ndecorators or function, both are possible.\nafterViewInit lifecycle hook - we are guarenteed to have access to those elements selected via viewChild / viewChildren.\nafterContentInit - gets access to those elements grabbed via contentChild / contentChildren.\nafterRender, afterNextRender hooks:\n\n\nexport class AppComponent {\nconstructor() {\nafterRender(() => {\n// renders when basically anything changes in the app anywhere.\n});\n\nafterNextRender(() => {\n// only be triggered for the next change anywhere in the app.\n});\n}\n}\n\nif we have a signal, and if we try to invoke the same within the class, angular wont setup the subscription.","signals--effect#Signals & Effect":"status = signal<'online' | 'offline'>('offline')\n\nconstructor() {\n// this.status() wont setup a subscription.\neffect((onCleanup) => {\n// within effect, if we use a signal, the subscription is setup.\n// auto cleans too.\n// when value changes, we gets notified.\nonCleanup(() => {\n// clears things like timers.\n})\n})\n}\n\nwhen using @for, we have $first, $last, $odd, $even, $count ( 17+ )\nolder version is for *ngFor\nset and update are ways to change signal values.\nwith input, we can use alias and transform function.","input--transform#Input & Transform":"Code example","custom-2-way-binding#Custom 2 way binding":"the event needs the input name along with \"Change\"\nWith 17.2+, we can use model()\n\n\n@Input() myItem: any;\n@Output() myItemChange = new EventEmitter<any>();\n\n// in the component, we can sue the 2 way binding syntax.\n\n<app-item [(myItem)]=\"itemVal\"></app-item>\n\n// 17.2+\nsize = model.required<{width: string; height: string}>() // makes it 2 way bindable\n// to update\nthis.size.set() // or update"}},"/directives":{"title":"Deep dive directives","data":{"":"Attribute & structural\nbuilt in & custom directives\nthey do not have templates\nenhancements for elements ( built in html elements or components )\nextra behaviors or settings can be added.\ncan change the configuration, styling or behavior of elements.\nThey are just there to enhance the properties, attributes or behavior of the elements.\nngModel with 2 way binding syntax helps 2 way binding.\nngModel enhances input elements by adding more classes, helps add 2 way binding etc\nngIf/@ifis another structural directive (17+)","custom-directive#Custom directive":"if we use input function, then it outputs a signal.\n\nExample codeCreate custom structural directive\nif we have a directive that holds some piece of functionality and that need to work along with other directives,\nwe can add hostDirectives to the component.\nOr, as the usual way, we can register the same in component imports & use it as a property in the component.\n\n\n@Component({\nhostDirectives: [LogDirective]\n})","pipes#Pipes":"can transform the way data is displayed.\nhow values are formatted and displayed.\npipes can be chained.\npipes can accept more parameters.\n\nPipes and custom pipesPure and impure pipes"}},"/services":{"title":"Servcies & DI","data":{"":"holds non-ui logic that needs to be shared across the application.\nhierarchial injection, tokens etc\nprovidedIn root helps us register the service automatically at the top most level in hierarchy. It gives a singleton & is tree shakeable.\nif a service holds a constructor that takes more services, we need the decorator.\nto provide a service as a dependency & make sure the component receives the singleton, we need to inject them.\nWe should not use the \"new\" keyword to start creating instances manually.\nconstructor injection is the usual way, there is also a modern way with inject method.\nwe can expose read only signals to make sure the data isnt manipulated accidentally.","angular-has-multiple-injectors#Angular has multiple injectors":"providedIn root is not the only way\nWe do not create service instances by ourselves. We request from angular.\nin main.ts, we could provide multiple applications and let the services be registered for both.\nAppRoot EnvironmentInjector, ModuleInjector, ElementInjector are the common ones.\na component reaches out to the element injector first to request a dependency. Then it checks AppRoot or ModuleInjector.\nThen it checks Platform injector, else null injector.","providing-a-service#Providing a service":"using injectable with providedIn root.\nelse, if we comment the decorator,\n\n\nbootstrapApplication(AppComponent, {\nproviders: [TaskService]\n})\n\nthis approach doesnt help tree shaking.","element-injector#Element injector":"closely tied to components/directives\ngo to component, and within the @Component decorator, use imports array.\nAll child of this components gets access to the service.\nwe can inject services into services.\nbut if we do not provide the decorator, we need to register in main.ts, if we try to do them within a component imports, we get an error.\nangular dev tools can help with visualizing them.","custom-di-token#Custom DI token":"providers: [TaskService]\n// is same as\nproviders: [{ provide: TaskService, useClass: TaskService}]\nExample codeInjection tokenToken injection within constructor with InjectUseValue example\nwe can make use of these in standalone as well as modules.","change-detection#Change detection":"angular's change detection mechanism.\nOnPush, signals, zoneless.\nBy default, we have a component tree, angular wraps the tree with zones.\nZone.js is a third party library\nIf a user clicks a button, angular is notified, it starts the CD process, visits all components in the application, takes a look at all templates & its bindings and checks whether it produces a new value.\nIf it does, the real DOM is updated with the new value.\ngetters get executed a lot. So be careful with it.\nSame logs gets logged twice in development. Change detection runs twice. Its a dev mode feature\ndetects unwanted changes that may gets trggered after the change detection being completed.\nIf the value is not same between 2 cycles, angular throws the error.","efficient-template-bindings#Efficient template bindings":"no expensive calculations in templates\ngetters should not do expensive calculations too.\nAvoid zone pollution - tell angular if certain events doesnt matter.\n\n\nprivate zone = inject(NgZone);\n\n//optout of watch mode\n\nthis.zone.runOutsizeAngular(() => {\n// whatever here wont trigger cd\n})","onpush-strategy#OnPush strategy":"the component will only change if the event occurs within a sub component tree, or if Input changes.\nor we can also manually trigger change detection.\nlimits the amount of things that can trigger change detection.\n\nOn Push example\nwith signals, its changes lead to component re-evaluation.\nwhen we use a service with signals & app uses OnPush,\n\nServices with signals and OnPushNon signal example","manually-changing-the-detection#Manually changing the detection":"private cdRef: inject(ChangeDetectorRef)\n\nngOnInit() {\nthis.messageService.messages$.subscribe(\n() => this.cdRef.markForCheck()\n)\n}","async-pipe#Async pipe":"when we use async pipe, the subscription and unsubscription will be done by framework itself.\nwhen the template does the subscription for us, it knows to re-render the component too.\n\nAsync example","zoneless#Zoneless":"if we use signals, we can get rid of zone.js\nif signal's value is changed anywhere, internally, signal can notify angular.\nsame is true for event binding.\nWith 18+, we can do zoneless.\nfine grained CD, smaller bundle, less listeners and checks.\nwherever the data changes, if we use signals, we can get rid of zone.\n\n\n// Step 1\nangular.json -> build -> polyfills array, remove zone.js\n\n// Step 2\nin main.ts,\nimport { provideExperimentalZonelessChangeDetection } from '@angular/core';\n\nbootstrapApplication(AppComponent, {\nproviders: [provideExperimentalZonelessChangeDetection()]\n})"}},"/rxjs":{"title":"RXJS Deep dive","data":{"":"subjects & related ones are observables\nAn observable is a concept introduced by rxjs\nIts an object that produces and contols a stream of data\noperators are an important feature.\nSignals vs observables - Looks almost the same to subject\nsignals are relatively new.\nrxjs has operators. Signals doesnt have them.\nObservables - pipeline of values emitted over time. Great for managing events & streamed data.\nSignals are values in a container. Great for managing application state.\nto convert signals to observables,\n\n\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop'\n\nclickCount = signal(0);\n\nconstructor() {\ntoObservable(this.clickCount)\n}\n\n// or\nclickCount = signal(0);\nclickCount$ = toObservable(this.clickCount)\n\nngOnInit() {\nconst sub =  this.clickCount$.subscribe({\nnext: val => console.log(val)\n})\n\nthis.destroyRef.onDestroy(() => {\nsub.unsubscribe()\n})\n}\n\nConvert observables to signals,\ninterval$ = interval(1000);\n\n// auto cleans up the subscription too.\nintervalSignal = toSignal(this.interval$, {\ninitialValue: 0,\nmanualCleanup: true // we dispose the observable manually.\n})"}},"/http":{"title":"HTTP Requests & responses","data":{"":"we never talk directly to the database.\nfrom the client side, we send a request, and we get back a response from the backend.","register-the-provider#Register the provider":"import { provideHttpClient } from '@angular/common/http';\n\nbootstrapApplication(AppComponent, {\nproviders: [provideHttpClient()],\n});\n\nCode example\nthe older way is to register them within the module providers array.\n\n\n@NgModule({\ndeclarations: [],\nimports: [BrowserModule, FormsModule],\nproviders: [provideHttpClient()],\nbootstrap: [AppComponent],\n})\nexport class AppModule {}\n\neither we can subscribe or use async pipe.\ncan unsubscribe within ngOnDestroy or use destroyRef.\nget is a generic\n\nFor full response\ngetAllUsers() {\nreturn this.http\n.get('https://reqres.in/api/users', {\nobserve: 'response', // gets full response , another option is events\n})\n.pipe(map((res: any) => res.body?.data));\n}\n\n// events\n\ngetAllUsers() {\nreturn this.http\n.get('https://reqres.in/api/users', {\nobserve: 'events', // gets full response\n})\n.pipe(map((res: any) => res.body?.data));\n}","loading-and-error-handling#Loading and error handling":"Code example","send-data-to-backend#Send data to backend":"this.http.put('url', {\nplaceId: id\n}).subscribe({\nnext: () => {},\nerr => {},\n() => console.log(\"complete\")\n})\n\noptimistic updates can be done.\nadd item to signals before sending the request, but make sure to roll back if something goes wrong.\nin catchError of service call, we can do the rollback. Also, check if the item is already present.","app-wide-error-management#App wide error management":"have an error service to hold and update error\ntrigger from wherever error occurs.\nin app component, DI the error service, and check if error is true and the show the message.","http-interceptor#HTTP Interceptor":"special functions that gets executed when a request is sent or a response is received.\n\n\n\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\n\nfunction loggingInterceptor(request: HttpRequest<unknown>, next: HttphandlerFn) {\nconst req = request.clone({\nheaders: request.headers.set('X-DEBUG', 'TESTING')\n});\nconsole.log(request)\nreturn next(req);\n}\n\n@NgModule({\ndeclarations: [],\nimports: [BrowserModule, FormsModule],\nproviders: [provideHttpClient(withInterceptors([loggingInterceptor]))],\nbootstrap: [AppComponent],\n})\nexport class AppModule {}","class-based-interceptors#Class based interceptors.":"import {\nHttpEvent,\nHttpHandler,\nHttpInterceptor,\nHttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nclass LoggingInterceptor implements HttpInterceptor {\nintercept(req: HttpRequest<unknown>, handler: HttpHandler): Observable<HttpEvent<any>> {\nconsole.log('Request URL: ' + req.url);\nreturn handler.handle(req);\n}\n}\n\nproviders: [\nprovideHttpClient(\nwithInterceptorsFromDi()\n),\n{ provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }\n]","http-response-interceptor#HTTP Response interceptor":"function loggingInterceptor(request: HttpRequest<unknown>, next: HttphandlerFn) {\n\nconsole.log(request)\nreturn next(request).pipe(\ntap({\nnext: event => {\nif(event.type === HttpEventType.Response) {\nconsole.log(\"Incoming response\", event.status, event.body)\n}\n}\n})\n);\n}"}},"/routing":{"title":"Routing - Deep dive","data":{"":"build up on what we already learned.\nexplore routing patterns\nwhenever we have a default export, next makes it available a params prop to the component.\nIt can also hold dynamic paths (params.id if we have named our file as [id]/page.js)","handle-not-found-errors-and-show-not-found-pages#Handle not found errors and show not found pages":"We could add it on nested paths too. Enter something that doesnt exist to see the page content.\n\n\napp/\nnot-found.js  // shows 404 .\nnews/\n[slug]\nnot-found.js\n\nand for error handling,\n\nimport { notFound } from 'next/navigation';\n\nconst NewsDetail = ({ params }) => {\nconst newsId = params.id;\nconst newsItem = DUMMY_NEWS.find(n => n.slug === newsId);\n\nif (!newsItem) {\nnotFound() // trigger not found error & nextjs shows closest not-found.js page\n}\n...\n}\nWe could use the not-found.js page in nested folders to have a more specific error page.","parallel-routes#Parallel routes":"A new routing pattern. Parallel routes starts with @ symbol.\nare routes that we can setup in nextjs is a feature that allows us to render the content of 2\nseparate routes with separate paths on one & same page\n\n\napp/\narchive/\n@archive/\npage.js\n@latest/\npage.js\nlayout.js\n\nto setup parallel routing, add a layout and a sub folder per parallel route.\nboth pages can be shown at the same time.\nhere, the layout component function receives one prop per parallel route along with children.\n\n\n// app/archive/layout.js\nimport React from 'react';\n\nconst ArchiveLayout = ({ archive, latest }) => {\nreturn (\n<div>\n<section id=\"archive-filter\">{archive}</section>\n<section id=\"archive-latest\">{latest}</section>\n</div>\n);\n};\n\nexport default ArchiveLayout;\nIf we navigate to /archive, then we see content of both pages.Think of a product page with some products on the top and a \"deal of the day\" items. We can search for our choice and based on that, what we see at the top changes, but it does not affect the deal of the day items.\napp/\narchive/\n@archive/\n[year]\npage.js\npage.js\n@latest/\npage.js\nlayout.js\nand to add more dynamic routes,\napp/\narchive/\n@archive/\n[year]\npage.js\npage.js\n@latest/\npage.js\nlayout.js\nin the [year]/page.js we grab a specific year and try to render the news for that year only.\nimport NewsList from '@/components/news-list';\nimport { getNewsForYear } from '@/lib/news';\nimport React from 'react';\n\nconst FilteredNewsPage = ({ params }) => {\nconst newsYear = params.year;\nconst news = getNewsForYear(newsYear);\nreturn <NewsList news={news} />;\n};\n\nexport default FilteredNewsPage;\nHere, if we try to render, we get a page not found error.\nThat is because we are in a parallel route setup. We are still within a layout, who tries to render the content of 2 different routes in the same page. Both routes work independant of each other. In the first route, we delve deeper and add a dynamic route, but the same hierarchy isnt made for the second route. One of the 2 parallel routes did not find a fitting page for the path we try to visit.\napp/\narchive/\n@archive/\n[year]\npage.js\npage.js\n@latest/\n[year]   <-- this is the expectation\npage.js\npage.js\nlayout.js\nInstead, we can add a default.js page as a fallback page.","default-page#Default page":"app/\narchive/\n@archive/\n[year]\npage.js\npage.js\n@latest/\ndefault.js\npage.js // delete this and use default if the content to be shown is the same for both\nlayout.js\n\nnext allows to have a default.js file instead of page.js\nif the content of page.js and default js is the same, we can delete the latter.\nwhen dealing with parallel routes, this files defines the fallback content\nif the route doesnt have a more specific content for the path that is currently loaded.","catch-all-routes#Catch all routes":"a standard dynamic route @archive/[year] can be converted into a catch all route. archive/@archive/[[...filter]].\nThe page.js within the [[...filter]] folder will be activated for any path segments after archive ( the root one )\n\n\napp/\narchive/\n@archive\n[[...filter]]\npage.js\npage.js\n@latest\ndefault.js\n\nif we get an error saying \"You cannot define a route with same specificity as optional catch all route\",\nit means, we have 2 conflicting page.js files. @archive/page.js conflits with @archive/[[...filter]]/page.js\nTherefore, grab the contents of @archive/page.js, delete the page.js file, and go to nested page.js, and use the content there.\n\n\n// @archive/[[...filter]]/page.js\n\nconst FilteredNewsPage = ({ params }) => {\nconst filter = params.filter;\nconst selectedYear = filter?.[0];\nconst selectedMonth = filter?.[1];\n\nlet news;\nlet links = getAvailableNewsYears();\n\nif (selectedYear && !selectedMonth) {\nnews = getNewsForYear(selectedYear);\nlinks = getAvailableNewsMonths(selectedYear);\n}\n\nif (selectedYear && selectedMonth) {\nnews = getNewsForYearAndMonth(selectedYear, selectedMonth);\nlinks = [];\n}\n\nlet newsContent = <p> No news available</p>;\n\nif (news && news.length > 0) {\nnewsContent = <NewsList news={news} />;\n}\n\nreturn (\n<>\n<header id=\"archive-header\">\n<nav>\n<ul>\n{links.map((link) => {\nconst href = selectedYear\n? `/archive/${selectedYear}/${link}`\n: `/archive/${link}`;\nreturn (\n<li key={link}>\n<Link href={href}>{link}</Link>\n</li>\n);\n})}\n</ul>\n</nav>\n</header>\n{newsContent}\n</>\n);\n};\n\nexport default FilteredNewsPage;","throwing-route-related-errors#Throwing route related errors":"for invalid path segments, /archive/2024/a/b, shows the default No news found message\nwe can add an error condition and to handle, add an error.js\nwe can add the below check, and throw an error. This will show a development time error screen.\n\n\nif (\n(selectedYear && !getAvailableNewsYears().includes(+selectedYear)) ||\n(selectedMonth &&\n!getAvailableNewsMonths(selectedYear).includes(+selectedMonth))\n) {\nthrow new Error('Invalid Filter');\n}\nto avoid seeing this, we need to handle the error with a fallback error.js page.\napp/\narchive/\n@archive\n[[...filter]]\npage.js\nerror.js\n@latest\ndefault.js\nMake sure the component is a client component\n'use client';\nconst FilterError = () => {\nreturn (\n<div id=\"error\">\n<h2> An error occured.. </h2>\n</div>\n);\n};\n\nexport default FilterError;\nand the closest error.js will be shown","server-vs-client-components#Server vs Client components":"react server components are only rendered on server.\nclient components are pre rendered on server, but later executed again on client / browser.\nerror.js must be a client component as client side code also can fail.\nas far as possible, keep components as server components","highlight-currently-active-path#Highlight currently active path":"a good practice is to outsource the client side code into a separate component.\nmake them as small as possible. Suppose, if we have a header component, instead of making the whole component a client side,\njust take the links and make a separate component\n\n\n'use client'\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\n\nexport default function NavLink({ href, children }) {\nconst path = usePathname();\n\nreturn (\n<Link href={href} className={path.startsWith(`/${href}`) ? 'active' : undefined}>{children}</Link>\n)\n}\n\n// and use it as\n\nimport NavLink from './nav-link';\n\nexport default function MainHeader() {\n// no need of usePathname here. Make this component a server component.\nreturn (\n<header id=\"main-header\">\n<nav>\n<ul>\n<li>\n<NavLink href=\"/news\"> News </NavLink>\n</li>\n<li>\n<NavLink href=\"/archive\"> Archive </NavLink>\n</li>\n</ul>\n</nav>\n</header>\n);\n}\n\nHere, MainHeader is still a server component.","nested-routes-inside-dynamic-routes#Nested routes inside dynamic routes":"let's explore interceptor routes.\nnested routes inside of dynamic routes will have access to those parameters.\n\n\napp/\nnews/\n[id]\nimage/\npage.js\n\nand the page will have access to the dynamic id. That is nothing new.\nconst ImagePage = ({ params }) => {\nconst newsItemSlug = params.id;\nconst newsItem = DUMMY_NEWS.find((n) => n.slug === newsItemSlug);\n\nif (!newsItem) {\nnotFound();\n}\nreturn (\n<div className=\"fullscreen-image\">\n<img src={`/images/news/${newsItem.image}`} alt={newsItem.title} />\n</div>\n);\n};\n\nexport default ImagePage;\nAn intercepting route is a route that sometimes get activated depending on whether we navigate to it from an internal link or from an external link or when we reloaded. It intercepts an internal navigation request, and a different page would be shown.\napp/\nnews/\n[id]\n[(.)image]\npage.js\nimage/\npage.js\n\nThe page.js can be,\nconst ImageInterceptedPage = ({ params }) => {\nconst newsItemSlug = params.id;\nconst newsItem = DUMMY_NEWS.find((n) => n.slug === newsItemSlug);\n\nif (!newsItem) {\nnotFound();\n}\nreturn (\n<>\n<h2> Intercepted! </h2>\n<div className=\"fullscreen-image\">\n<img src={`/images/news/${newsItem.image}`} alt={newsItem.title} />\n</div>\n</>\n);\n};\n\nexport default ImageInterceptedPage;\nHere, if we reload the page, this won't be shown, instead the content of image/page.js is shown but if coming after clicking on the Link element, this will be shown. ([(/image)/page.js])We get to show different page depending on how we got to this page.This becomes a useful feature when clubbed with parallel routes. Eg: Show the content in a model if intercepted, or a full screen page if we reloaded the page or entered the link manually.","combine-parallel--intercepting-routes#Combine parallel & intercepting routes":"The below setup might sound confusing. So be attentive on the folder structure.\napp/\nnews/\n[id]\n@details/\n@modal/\n[(.)image]\npage.js\ndefault.js/page.js\nimage/\npage.js\nlayout\n\nNote: the parallel routes doesnt add anything to URL. It is for organizational purpose.The layout being,\nimport React from 'react';\n\nconst NewsDetailLayout = ({ children, modal }) => {\nreturn (\n<>\n{modal}\n{children}\n</>\n);\n};\n\nexport default NewsDetailLayout;\nand the default.js within @modal being\nimport React from 'react';\n\nconst ModalDefault = () => {\nreturn null;\n};\n\nexport default ModalDefault;\nFrom the detail page, if we click on the image, then now, we see that the content is shown as a modal overlay.\nIf we refresh, it is shown as a separate content page.","navigate-programmatically#Navigate programmatically":"To click on modal backdrop, and navigate to somewhere, we need the useRouter() from the next/navigation package.\nNow, if we click on the modal, it routes back to the previous route using the back() method.\n'use client';\n\nimport { useRouter } from 'next/navigation';\n\nconst ImageInterceptedPage = ({ params }) => {\nconst router = useRouter();\n\nreturn (\n<>\n<div className=\"modal-backdrop\" onClick={() => router.back()} />\n<dialog className=\"modal\" open>\n...\n</dialog>\n</>\n);\n};\n\nexport default ImageInterceptedPage;","route-groups#Route Groups":"We can have one layout for certain group of pages, and some other layout for another set of routes.\nWe need a different route for the starting page without navbar, and the rest with navbar.\nwe can achieve that with route groups.\n\n\napp/\n(content)\nlayout.js\nnot-found.js\n(marketing)\nlayout.js\npage.js\nlayout.js\nThe outer layout.js as a child to app\nimport './globals.css';\n\nexport const metadata = {\ntitle: 'Next.js Page Routing & Rendering',\ndescription: 'Learn how to route to different pages.',\n};\n\nexport default function RootLayout({ children }) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n);\n}\nand inside the (marketing) folder, since we have a page.js, it tries to render that as the home page\nSo, the layout.js corresponding to that will be loaded. Since this is home page, we don't need the navbar there.\nSince the globals.css was already imported at root layout, we can omit that too.\nexport const metadata = {\ntitle: 'Next.js Page Routing & Rendering',\ndescription: 'Learn how to route to different pages.',\n};\n\nexport default function MarketingLayout({ children }) {\nreturn <main>{children}</main>;\n}\nFor the layout.js inside the (content), we need the navbar.\nimport MainHeader from '@/components/MainHeader';\n\nexport const metadata = {\ntitle: 'Next.js Page Routing & Rendering',\ndescription: 'Learn how to route to different pages.',\n};\n\nexport default function ContentLayout({ children }) {\nreturn (\n<div id=\"page\">\n<MainHeader />\n{children}\n</div>\n);\n}","build-api-with-route-handlers#Build API with route handlers":"In a route handler, we can export various functions ( CRUD ) which must have an HTTP method name.\nWe can setup routes that doesnt return pages, but json data. We can setup API like routes.\napp/\napi/\nroute.ts\nand within the route.ts file, have the below format, and hit the http:localhost:3000/api route on browser.\nexport function GET(request) {\nconsole.log(request);\nreturn new Response('Hello, Next.js!');\n}","middleware#Middleware":"At the root, add a middleware.js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(req, res) {\nconsole.log('middleware');\nreturn NextResponse.next();\n}\n// filters\nexport const config = {\nmatcher: '/news/:path*',\n};"}},"/forms":{"title":"Forms","data":{"":"2 main ways\nTemplate driven, reactive forms","template-driven#Template driven":"easy to get started\ncomplex logic is tricky\nWith reactive forms, we set up in the typescript code and link them.\nSetup may be complex, but flexible with more complex scenarios.\nWith template driven, we add special directives to the form in template\nmake angular aware of those\nngModel registers an input element with angular & allows angualr to manage it.\nto get access to the form, we create a template variable and assign them to ngForm identifier.\n\nExample codeValidations and programmatic controlReactive form exampleBuilding a custom validatorAsynchronous validatorNested forms & Adding Form ArraysForm group validation\n// To make it more configurable\nfunction validateAddress(control1: string, control2: string) {\nreturn (control: AbstractControl) => {\nconst val1 = control.get(control1)?.value;\nconst val2 = control.get(control2)?.value;\n\nif (val1.length >= 6 && val2 !== '') {\nreturn null;\n}\n\nreturn {\naddressinValid: true,\n};\n}\n}\n\n// and can invoke the same\nvalidators: [validateAddress('pin', 'city')],"}},"/intermediate":{"title":"Intermediate topics","data":{"":"","server-actions-for-form-submissions#Server Actions for form submissions":"A server action is guarenteed to be executed only on sevrer side.\nuse client is used within components or files, whereas use server is within a function.\nTo make a function a server action, we need to mark it as `async too.\nWe can assign a server action function as a value to the action property of form.\nWhen the form is submitted,next js behind scenes create a request and send it to next js server, so that the function gets triggered and handle form submission there, but ONLY ON SERVER.\nThat form data submitted will be available as a formData object.\n\n\nimport ImagePicker from '@/components/meals/image-picker';\nimport classes from './page.module.css';\n\nexport default function ShareMealPage() {\n// makes the form data automatically available as a prop\nasync function shareMeal(formData) {\n'use server';\nconst meal = {\ntitle: formData.get('title'),\nsummary: formData.get('summary'),\ninstructions: formData.get('instructions'),\nimage: formData.get('image'),\ncreator: formData.get('name'),\ncreator_email: formData.get('email'),\n};\n// logs on server terminal, can save to DB later.\nconsole.log(meal);\n}\nreturn (\n<>\n<main className={classes.main}>\n<form className={classes.form} action={shareMeal}>\n<input type=\"text\" id=\"name\" name=\"name\" required />\n<input type=\"email\" id=\"email\" name=\"email\" required />\n<input type=\"text\" id=\"title\" name=\"title\" required />\n<input type=\"text\" id=\"summary\" name=\"summary\" required />\n<ImagePicker label=\"Your image\" name=\"image\" />\n<textarea id=\"instructions\" name=\"instructions\" required></textarea>\n<button type=\"submit\"> Share </button>\n</form>\n</main>\n</>\n);\n}\n\nthis will work only if the component is not a client component.\nwe are not allowed to have server actions in a client component file.","storing-server-actions-in-separate-files#Storing server actions in separate files":"we can add the server function inside the component only if it is not a client component.\nIf it is marked as use client, it wont work.\nWe can save server actions in separate file.\n\n\n// in lib/actions.js\n\n'use server';\n\nexport async function shareMeal(formData) {\nconst meal = {\ntitle: formData.get('title'),\nsummary: formData.get('summary'),\ninstructions: formData.get('instructions'),\nimage: formData.get('image'),\ncreator: formData.get('name'),\ncreator_email: formData.get('email'),\n};\n// logs on server terminal\nconsole.log(meal);\n}\n\n// in share/page.js\n// 'use client'; // if we need to, we can mark it as client side component\nimport { shareMeal } from '@/lib/actions';\n\n<form className={classes.form} action={shareMeal}>\n...\n</form>;\n\nfor technical reasons, we cant mix both in same file, but can import a server action from another file\nand use it in a client component marked with use client directive.","storing-uploaded-images--store-data-in-db#Storing uploaded images & store data in DB":"storing images in DB is a bad idea.\n\n\n// libs/meals.js\n\nimport sql from 'better-sqlite3';\nimport slugify from 'slugify';\nimport xss from 'xss';\nimport fs from 'node:fs';\n\nexport async function saveMeal(meal) {\nmeal.slug = slugify(meal.title, { lower: true });\nmeal.instructions = xss(meal.instructions);\nconst extn = meal.image.name.split('.').pop();\nconst fileName = `${meal.slug}.${extn}`;\n\nconst stream = fs.createWriteStream(`public/images/${fileName}`);\nconst bufferedImage = await meal.image.arrayBuffer();\n\nstream.write(Buffer.from(bufferedImage), (err) => {\nif (err) {\nthrow new Error('saving image failed..');\n}\n});\nmeal.image = `/images/${fileName}`;\n\ndb.prepare(\n`\nINSERT INTO meals\n(title, summary, instructions, creator, creator_email, image, slug)\nVALUES (\n@title,\n@summary,\n@instructions,\n@creator,\n@creator_email,\n@image,\n@slug\n)\n`\n).run(meal); // order matters\n}\n\n// and in libs/actions.js\n\nimport { saveMeal } from './meals';\nimport { redirect } from 'next/navigation';\n\nexport async function shareMeal(formData) {\nconst meal = {\ntitle: formData.get('title'),\nsummary: formData.get('summary'),\ninstructions: formData.get('instructions'),\nimage: formData.get('image'),\ncreator: formData.get('name'),\ncreator_email: formData.get('email'),\n};\nawait saveMeal(meal);\nredirect('/meals'); // redirects the user to a different page.\n}\nOnce we submit the form, we see the new entry on the meals page.\nBut during submission, it might take time. We need to let user know that something is happening.","manage-form-submission-status#Manage form submission status":"can use useFormStatus() hook.\nfor the hook to give the status, it should be inside the form component as a child component.\n\nSo we create a separate component, a lean component with use client where only this submit button needs to be rendered on client. The component with the form who consumes this, can be a server component. The hook changes status based on the ongoing request.\n'use client';\nimport { useFormStatus } from 'react-dom';\n\nexport default function MealsFormSubmit() {\nconst { pending } = useFormStatus();\nreturn (\n<button disabled={pending}> {pending ? 'Submitting' : 'Share Meal'}</button>\n);\n}\nand use the component where we have included the hook.\n// share/page.js\n\nimport ImagePicker from '@/components/meals/image-picker';\nimport classes from './page.module.css';\nimport { shareMeal } from '@/lib/actions';\nimport MealsFormSubmit from '@/components/meals/meals-form-submit';\n\nexport default function ShareMealPage() {\nreturn (\n<>\n<header className={classes.header}>\n<h1>\nShare your <span className={classes.highlight}>favorite meal</span>\n</h1>\n<p>Or any other meal you feel needs sharing!</p>\n</header>\n<main className={classes.main}>\n<form className={classes.form} action={shareMeal}>\n<div className={classes.row}>\n<p>\n<label htmlFor=\"name\">Your name</label>\n<input type=\"text\" id=\"name\" name=\"name\" required />\n</p>\n<p>\n<label htmlFor=\"email\">Your email</label>\n<input type=\"email\" id=\"email\" name=\"email\" required />\n</p>\n</div>\n<p>\n<label htmlFor=\"title\">Title</label>\n<input type=\"text\" id=\"title\" name=\"title\" required />\n</p>\n<p>\n<label htmlFor=\"summary\">Short Summary</label>\n<input type=\"text\" id=\"summary\" name=\"summary\" required />\n</p>\n<p>\n<label htmlFor=\"instructions\">Instructions</label>\n<textarea\nid=\"instructions\"\nname=\"instructions\"\nrows=\"10\"\nrequired\n></textarea>\n</p>\n<ImagePicker label=\"Your image\" name=\"image\" />\n<p className={classes.actions}>\n<MealsFormSubmit />\n</p>\n</form>\n</main>\n</>\n);\n}","server-side-input-validation#Server side input validation":"// libs/actions.js\n\n'use server';\n\nimport { redirect } from 'next/navigation';\nimport { saveMeal } from './meals';\n\n// have util methods like this.\nfunction isInvalidText(txt) {\nreturn !txt || txt.trim() === '';\n}\n\nexport async function shareMeal(formData) {\nconst meal = {\ntitle: formData.get('title'),\nsummary: formData.get('summary'),\ninstructions: formData.get('instructions'),\nimage: formData.get('image'),\ncreator: formData.get('name'),\ncreator_email: formData.get('email'),\n};\n// similarly other fields need to be added.\nif (isInvalidText(meal.title) || isInvalidText(meal.summary)) {\n// shows the closest error.js\nthrow new Error('invalid input');\n}\nawait saveMeal(meal);\nredirect('/meals');\n}\nThe problem is that, it shows an error.js thereby destroying the inputs we had on the form.\nBetter UX is to stay on the form page and show error on that page itself.","server-action-responses--useactionstate#Server Action responses & useActionState":"In server actions, it is not just about redirection or throwing errors.\nWe can return response objects. ( values )\nexport async function shareMeal(formData) {\nconst meal = {\n...\n};\n\nif (isInvalidText(meal.title) || isInvalidText(meal.summary)) {\nreturn {\nmessage: 'Invalid input..'\n}\n}\nawait saveMeal(meal);\nredirect('/meals');\n}\nTo handle such validation messages that we return as objects, we can use another hook. The hook is responsible for managing the state of the page / component which uses the form which will be submitted with the help of server actions.\nimport { useFormState } from 'react-dom';\n// there is a useActionState equivalent too.\n// initial value that needs to be returned from hook before action is triggered and getting back a message\nconst [state, formAction] = useFormState(serverAction, {\nmessage: null,\n});\nThe state is the current state, and formAction which can be set to the action property.\n// share/page.js\n\n'use client';\nimport { useFormState } from 'react-dom';\n\nexport default function ShareMealPage() {\nconst [state, formAction] = useFormState(shareMeal, { message: null });\n\nreturn (\n<>\n<main className={classes.main}>\n<form className={classes.form} action={formAction}>\n...\n{state.message ? state.message : null}\n</form>\n</main>\n</>\n);\n}\nand in the actions file, the signature changes slightly.\n\n// lib/actions.js\n// add prevState as the first argument.\n// It can be the default state object or based on response, something different\nexport async function shareMeal(prevState, formData) {\nconst meal = {\n...\n}\n\nif (isInvalidText(meal.title) || isInvalidText(meal.summary)) {\nreturn {\nmessage: 'Invalid input'\n}\n}\nawait saveMeal(meal);\nredirect('/meals')\n}","build-for-production#Build for production":"There are issues with caching\nnpm run build does a prod build. Then run it with npm run start\nif we run that and revisit the meals page, adding a new meal brings a small problem.\nWhen redirected, the meal which we added is missing.\nNext performs caching. With production, next js pre renders all the pages of the app which can be pre-generated.\nSo basically, all non dynamic pages are pre generated.\nNext caches the pre rendered pages. Downside being, it never refetches the meals. So newly entered data is lost.\nBecause the code never executes again. It uses the pre rendered pages itself.","trigger-cache-revalidations#Trigger cache revalidations":"We need to tell Next to throw away the cache when we add new data.\n\n\n// libs/action.js\n'use server';\n\nimport { redirect } from \"next/navigation\";\nimport { saveMeal } from \"./meals\";\nimport { revalidatePath } from \"next/cache\";\n\nexport async function shareMeal(prevState, formData) {\nconst meal = {\n...\n}\n\nawait saveMeal(meal);\n\n// only this path will be revalidated, not nested paths. Alternatively,\n// if we set layout as the second parameter,  its the layout that will be revalidated. That is,\n// next throws the cache for those revaliated pages/layouts.\nrevalidatePath('/meals')\nrevalidatePath('/meals', 'layout')\n\nredirect('/meals')\n}\n// if we build again, the cache will be cleared on adding new meal.\n\nThe problem being, the image wont be shown. Meal is there though.\nWe store the images in file system in public/images folder. Once built for prod, the \".next\" folder is used.\nAdding more images to public folder doesnt help, it gets ignored.\nWe should store the files in something like AWS S3.","adding-static-metadata#Adding static metadata":"In root layout, we export a metadata const.\nIf we add the metadata to a layout, it will automatically be added to all the pages\nwithin a layout unless a page specifies its own metadata\n\n\n// In meals/page.js, we have a specific metadata\n\nexport const metadata = {\ntitle: 'All meals',\ndescription: 'Check out all the meal options',\n};\nNow, the localhost:3000/meals have a new title. Check browser tab.","adding-dynamic-metadata#Adding dynamic metadata":"we need to export a specific function.\n// in [mealSlug]/page.js\n\nexport async function generateMetadata({ params }) {\nconst meal = getMeal(params.mealSlug);\nif (!meal) {\nnotFound();\n}\nreturn {\ntitle: meal.title,\ndescription: meal.description,\n};\n}"}},"/data-fetch":{"title":"Data fetching - Deep dive","data":{"":"","option-1-client-side-data-fetching#Option 1: Client side data fetching.":"Assuming we have a backend from which we fetch data, we can do it like the traditional react way using useEffect and fetch\nBe sure to add the use client directive\n\n\n// app/(content)/news/page.js\n\n'use client';\nimport NewsList from '@/components/news-list';\nimport React, { useEffect, useState } from 'react';\n\nconst NewsPage = () => {\nconst [error, setError] = useState();\nconst [isLoading, setLoading] = useState(false);\nconst [news, setNews] = useState([]);\n\nuseEffect(() => {\nasync function fetchNews() {\nsetLoading(true);\nconst response = await fetch('http://localhost:8080/news');\nif (!response.ok) {\nsetError('Failed to fetch');\nsetLoading(false);\n}\nsetLoading(false);\nconst news = await response.json();\nsetNews(news);\n}\nfetchNews();\n}, []);\n\nif (error) {\nreturn <p> Error!</p>;\n}\nif (isLoading) {\nreturn <p> Loading...</p>;\n}\n\nlet newsContent;\nif (news && news.length > 0) {\nnewsContent = <NewsList news={news} />;\n}\nreturn (\n<div>\n<h1> News Page </h1>\n{newsContent}\n</div>\n);\n};\n\nexport default NewsPage;\nThis is less ideal than running them on server.","option-2-server-side-data-fetching#Option 2: Server side data fetching":"Server components can return promises too. So we can make them async. This gives SEO advantage too.\nimport NewsList from '@/components/news-list';\n\nconst NewsPage = async () => {\nconst response = await fetch('http://localhost:8080/news');\nif (!response.ok) {\nthrow new Error('Failed to fetch news');\n}\nconst news = await response.json();\nreturn (\n<div>\n<h1> News Page </h1>\n<NewsList news={news} />\n</div>\n);\n};\n\nexport default NewsPage;\nWe can fetch the data directly from backend. We can directly reach out to the DB from the next js app.\nmake sure, we move the data.db from backend folder to the root of the app first.\n// lib/news.js\n\nimport sql from 'better-sqlite3';\n\nconst db = sql('data.db');\n\nexport function getAllNews() {\nconst news = db.prepare('SELECT * FROM news').all();\nreturn news;\n}\nand then, in the component\nimport NewsList from '@/components/news-list';\nimport { getAllNews } from '@/lib/news';\n\nconst NewsPage = async () => {\n// here, the function directly connects to Database to fetch the data\nconst news = getAllNews();\nreturn (\n<div>\n<h1> News Page </h1>\n<NewsList news={news} />\n</div>\n);\n};\n\nexport default NewsPage;\nThis is the best way to fetch data if we own the data base. If we have an external api, we need to send another HTTP request though.\nTo simulate a slow network, we can convert the method into an async one and add a promise delay there.\nexport async function getAllNews() {\nconst news = db.prepare('SELECT * FROM news').all();\nawait new Promise((resolve) => setTimeout(resolve, 1000));\nreturn news;\n}\nand in the component, as a sibling to page, we add a loading.js\napp/\n(content)/\nnews/\npage.js\nloading.js\n\nand then, in the page component,\nimport NewsList from '@/components/news-list';\nimport { getAllNews } from '@/lib/news';\n\nconst NewsPage = async () => {\nconst news = await getAllNews();\nreturn (\n<div>\n<h1> News Page </h1>\n<NewsList news={news} />\n</div>\n);\n};\n\nexport default NewsPage;\nand for the NewsDetail component, while loading, it shows the closest loading.js content.\nimport { getNewsItem } from '@/lib/news';\n\nconst NewsDetail = async ({ params }) => {\nconst newsId = params.id;\nconst newsItem = await getNewsItem(newsId);\n};\nand in the other page, add respective loading.js nearby, and then\nconst ImagePage = async ({ params }) => {\nconst newsItemSlug = params.id;\nconst newsItem = await getNewsItem(newsItemSlug);\n\nif (!newsItem) {\nnotFound();\n}\nreturn (\n<div className=\"fullscreen-image\">\n<img src={`/images/news/${newsItem.image}`} alt={newsItem.title} />\n</div>\n);\n};\nWith the interceptor page, we have a problem. Since we need to mark it as use client since we use the useRouter hook, we cannot use the async await syntax. Instead, the alternate option is to make a smaller component, offload the logic to that component, let it hold the logic to client side render, and use them in the bigger component which is a server rendered component.Create a smaller client side component\n'use client';\nimport { useRouter } from 'next/navigation';\nimport React from 'react';\n\nconst ModalbackDrop = () => {\nconst router = useRouter();\nreturn <div className=\"modal-backdrop\" onClick={() => router.back()} />;\n};\n\nexport default ModalbackDrop;\nand then, use that within the server component, we can remove the use client directive, add async await and remove the hooks.\nimport ModalbackDrop from '@/components/modal-backdrop';\nimport { getNewsItem } from '@/lib/news';\n\nconst ImageInterceptedPage = async ({ params }) => {\nconst newsItemSlug = params.id;\nconst newsItem = await getNewsItem(newsItemSlug);\n\nif (!newsItem) {\nnotFound();\n}\nreturn (\n<>\n<ModalbackDrop />\n...\n</>\n);\n};\n\nexport default ImageInterceptedPage;\nNow, the functionality should work as usual. We can add a loading.js to the closest sibling if we need to show specific loading messages.Note, the name of the file should be default.js, and not page.js below.\napp/\n(content)/\nnews/\n[slug]/\n@modal/\ndefault.js // not page.js\nOn other pages too, we just need to do similar changes\nimport NewsList from '@/components/news-list';\nimport { getLatestNews } from '@/lib/news';\nimport React from 'react';\n\nconst LatestPage = async () => {\nconst latestNews = await getLatestNews();\nreturn (\n<>\n<h2> Latest News </h2>\n<NewsList news={latestNews} />\n</>\n);\n};\n\nexport default LatestPage;","granular-data-fetching-with-suspense#Granular data fetching with Suspense.":"Here, we create smaller components and delegate logic to it, wrap the same with a Suspense so that we are only showing a fallback for that component and its loading fallback. Basically, just a refactor, done in a granular way.\nimport NewsList from '@/components/news-list';\nimport {\ngetAvailableNewsMonths,\ngetAvailableNewsYears,\ngetNewsForYear,\ngetNewsForYearAndMonth,\n} from '@/lib/news';\nimport Link from 'next/link';\nimport React, { Suspense } from 'react';\n\nasync function FilterHeader({ year, month }) {\nconst getAvailableNewsYrs = await getAvailableNewsYears();\nlet links = getAvailableNewsYrs;\n\nconst getAvailableNewsMnths = await getAvailableNewsMonths(year);\n\nif (\n(year && !getAvailableNewsYrs.includes(year)) ||\n(month && !getAvailableNewsMnths.includes(month))\n) {\nthrow new Error('Invalid Filter');\n}\n\nif (year && !month) {\nlinks = await getAvailableNewsMonths(year);\n}\n\nif (year && month) {\nlinks = [];\n}\n\nreturn (\n<header id=\"archive-header\">\n<nav>\n<ul>\n{links.map((link) => {\nconst href = year ? `/archive/${year}/${link}` : `/archive/${link}`;\nreturn (\n<li key={link}>\n<Link href={href}>{link}</Link>\n</li>\n);\n})}\n</ul>\n</nav>\n</header>\n);\n}\n\nasync function FilteredNews({ year, month }) {\nlet news;\nif (year && !month) {\nnews = await getNewsForYear(year);\n} else if (year && month) {\nnews = await getNewsForYearAndMonth(year, month);\n}\nlet newsContent = <p> No news available</p>;\n\nif (news && news.length > 0) {\nnewsContent = <NewsList news={news} />;\n}\nreturn newsContent;\n}\n\nconst FilteredNewsPage = async ({ params }) => {\nconst filter = params.filter;\nconst selectedYear = filter?.[0];\nconst selectedMonth = filter?.[1];\n\nreturn (\n<>\n<Suspense fallback={<p>Loading header..</p>}>\n<FilterHeader year={selectedYear} month={selectedMonth} />\n</Suspense>\n\n<Suspense fallback={<p>Loading news content..</p>}>\n<FilteredNews year={selectedYear} month={selectedMonth} />\n</Suspense>\n</>\n);\n};\n\nexport default FilteredNewsPage;"}},"/mutate":{"title":"Mutate Data - Deep dive","data":{"":"When we enter the data, we need to store them in a database.\nOption 1 is to have a standalone backend, a separate one that recives request from next js app and store/mutate data. But this is overly complex and unnecessary extra server.\nOption 2 is to have an integrated nextjs app. The app itself contains the data mutation code & reach out to data stores directly.\n\nWe could also have some route handlers inside the /api/posts/route.jsNext offers a better way of data submission & mutation.","server-actions#Server actions":"It is not a nextjs specific feature, but react feature itself, if we use react in an environment where it works.\nOn a standard react project, it won't work though.\nServer actions must be async, and needs a use server directive.\nWe just need to add the logic for form submission within the server action.\n\n\nimport { storePost } from '@/lib/posts';\n\nexport default function NewPostPage() {\nasync function createPost(formData) {\n// a form action when added with a use server directive becomes a server action\n'use server';\nconst title = formData.get('title');\nconst image = formData.get('image');\nconst content = formData.get('content');\n\nstorePost({\nimageUrl: '',\ntitle,\ncontent,\nuserId: 1,\n});\n}\n\nreturn (\n<>\n<h1>Create a new post</h1>\n<form action={createPost}>\n<input type=\"text\" id=\"title\" name=\"title\" />\n<input\ntype=\"file\"\naccept=\"image/png, image/jpeg\"\nid=\"image\"\nname=\"image\"\n/>\n<textarea id=\"content\" name=\"content\" rows=\"5\" />\n<p>\n<button type=\"reset\">Reset</button>\n<button>Create Post</button>\n</p>\n</form>\n</>\n);\n}","provide-user-feedback-with-useformstatus-hook#Provide user feedback with useFormStatus hook":"Here, we create a separate client component, and this must reside within the form element of the parent.\nThen only this setup will work. It should be marked with the use client too.\n'use client';\nimport { useFormStatus } from 'react-dom';\n\nconst FormSubmit = () => {\n// gives form submission details of surrounding form\nconst status = useFormStatus();\n\nif (status.pending) {\nreturn <p> Creating post..</p>;\n}\nreturn (\n<>\n<button type=\"reset\">Reset</button>\n<button>Create Post</button>\n</>\n);\n};\n\nexport default FormSubmit;\nand lets use this component within the form section of the consuming component\nimport FormSubmit from '@/components/form-submit';\nimport { storePost } from '@/lib/posts';\nimport { redirect } from 'next/navigation';\n\nexport default function NewPostPage() {\nasync function createPost(formData) {\n// a form action when added with a use server directive becomes a server action\n'use server';\nconst title = formData.get('title');\nconst image = formData.get('image');\nconst content = formData.get('content');\n\nawait storePost({\nimageUrl: '',\ntitle,\ncontent,\nuserId: 1,\n});\nredirect('/feed');\n}\n\nreturn (\n<>\n<h1>Create a new post</h1>\n<form action={createPost}>\n<input type=\"text\" id=\"title\" name=\"title\" />\n<input\ntype=\"file\"\naccept=\"image/png, image/jpeg\"\nid=\"image\"\nname=\"image\"\n/>\n<textarea id=\"content\" name=\"content\" rows=\"5\" />\n<FormSubmit />\n</form>\n</>\n);\n}","important-change#Important change":"Note: instead of useFormState hook, react team changed the name to useActionState. And also, the import path changed too.\nBut this is made available only on some latest Nextjs versions.\nimport { useFormState } from 'react-dom';\nimport { useActionState } from 'react';","validate-user-input-with-useformstate-hook#Validate user input with useFormState hook":"We need to validate the data on server to make sure, user hasn't tampered with it.\nInside the server action, we can have validation logic and in the end, if we can return an object with the details based on which the form can show validation messages, it will be great. We can do that with useFormState or useActionState which is the newer name of the same.Have a client component\n// post-form.js\n\n'use client';\n\nimport { useFormState } from 'react-dom';\nimport FormSubmit from './form-submit';\n\nconst PostForm = ({ action }) => {\nconst [state, formAction] = useFormState(action, {});\n\nreturn (\n<>\n<h1>Create a new post</h1>\n<form action={formAction}>\n<p className=\"form-control\">\n<label htmlFor=\"title\">Title</label>\n<input type=\"text\" id=\"title\" name=\"title\" />\n</p>\n<p className=\"form-control\">\n<label htmlFor=\"image\">Image URL</label>\n<input\ntype=\"file\"\naccept=\"image/png, image/jpeg\"\nid=\"image\"\nname=\"image\"\n/>\n</p>\n<p className=\"form-control\">\n<label htmlFor=\"content\">Content</label>\n<textarea id=\"content\" name=\"content\" rows=\"5\" />\n</p>\n<p className=\"form-actions\">\n<FormSubmit />\n</p>\n{state.errors && (\n<ul className=\"form-errors\">\n{state.errors.map((error) => (\n<li key={error}>{error}</li>\n))}\n</ul>\n)}\n</form>\n</>\n);\n};\n\nexport default PostForm;\nand then, we can use this inside of a server component\nimport PostForm from '@/components/post-form';\nimport { storePost } from '@/lib/posts';\nimport { redirect } from 'next/navigation';\n\nexport default function NewPostPage() {\nasync function createPost(prevState, formData) {\n'use server';\nconst title = formData.get('title');\nconst image = formData.get('image');\nconst content = formData.get('content');\n\nlet errors = [];\n\nif (!title || title.trim().length === 0) {\nerrors.push('Title is required');\n}\n\nif (!content || content.trim().length === 0) {\nerrors.push('Content is required');\n}\n\n// this error object returns an array. That is handled in state.errors above.\n\nif (errors.length > 0) {\nreturn { errors };\n}\n\nawait storePost({\nimageUrl: '',\ntitle,\ncontent,\nuserId: 1,\n});\nredirect('/feed');\n}\n\nreturn <PostForm action={createPost} />;\n}\nNow, upon form submission, we get back the error messages and based on that, we can display the same within the server component that holds the client component.","store-server-actions-in-separate-files#Store server actions in separate files":"At the root, we can create actions/post.js and within that\n'use server';\n\nimport { storePost } from '@/lib/posts';\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(prevState, formData) {\nconst title = formData.get('title');\nconst image = formData.get('image');\nconst content = formData.get('content');\n\nlet errors = [];\n\nif (!title || title.trim().length === 0) {\nerrors.push('Title is required');\n}\n\nif (!content || content.trim().length === 0) {\nerrors.push('Content is required');\n}\n\nif (errors.length > 0) {\nreturn { errors };\n}\n\nawait storePost({\nimageUrl: '',\ntitle,\ncontent,\nuserId: 1,\n});\nredirect('/feed');\n}\nand now, we can use this server action inside the page\nimport { createPost } from '@/actions/posts';\nimport PostForm from '@/components/post-form';\n\nexport default function NewPostPage() {\nreturn <PostForm action={createPost} />;\n}\nThis should work exactly as it is.Note: use server does not guarentee that code will only execute on server. This won't hide code from the client. But it is just a hint telling Nextjs that something should become a server action.There is a server-only package which can do that.","uploading--storing-images#Uploading & storing images":"AWS3 or cloudinary can be option.Have an account on cloudinary for free.\nInstall it.\nnpm i cloudinary\nin libs/cloudinary, add the following.\nimport { v2 as cloudinary } from 'cloudinary';\n\nif (!process.env.CLOUDINARY_CLOUD_NAME) {\nthrow new Error('CLOUDINARY_CLOUD_NAME is not set');\n}\n\nif (!process.env.CLOUDINARY_API_KEY) {\nthrow new Error('CLOUDINARY_API_KEY is not set');\n}\n\nif (!process.env.CLOUDINARY_API_SECRET) {\nthrow new Error('CLOUDINARY_API_SECRET is not set');\n}\n\ncloudinary.config({\ncloud_name: process.env.CLOUDINARY_CLOUD_NAME,\napi_key: process.env.CLOUDINARY_API_KEY,\napi_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\nexport async function uploadImage(image) {\nconst imageData = await image.arrayBuffer();\nconst mime = image.type;\nconst encoding = 'base64';\nconst base64Data = Buffer.from(imageData).toString('base64');\nconst fileUri = 'data:' + mime + ';' + encoding + ',' + base64Data;\nconst result = await cloudinary.uploader.upload(fileUri, {\nfolder: 'nextjs-course-mutations',\n});\nreturn result.secure_url;\n}\nFrom the cloudinary dashboard, add the env variables in the .env.local\nCLOUDINARY_CLOUD_NAME=your_username\nCLOUDINARY_API_KEY=1234567890\nCLOUDINARY_API_SECRET=some_random_keys\nWith that, we are ready to upload images to cloudinary from our actions\n// actions/posts.js\n\n'use server';\n\nimport { uploadImage } from '@/lib/cloudinary';\nimport { storePost } from '@/lib/posts';\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(prevState, formData) {\nconst title = formData.get('title');\nconst image = formData.get('image');\nconst content = formData.get('content');\n\nlet errors = [];\n\nif (!title || title.trim().length === 0) {\nerrors.push('Title is required');\n}\n\nif (!content || content.trim().length === 0) {\nerrors.push('Content is required');\n}\n\nif (!image || image.size === 0) {\nerrors.push('Image is required');\n}\n\nif (errors.length > 0) {\nreturn { errors };\n}\n\nlet imageUrl;\ntry {\nimageUrl = await uploadImage(image);\n} catch (error) {\nthrow new Error('Image upload failed..');\n}\n\nawait storePost({\nimageUrl,\ntitle,\ncontent,\nuserId: 1,\n});\nredirect('/feed');\n}\nand it should add the same under the bucket name provided in cloudinary dashboard's Media Explorer section.","alternate-ways-to-use-configure--trigger-server-actions#Alternate ways to use, configure & trigger server actions":"In the actions file,\nexport async function togglePostLikeStatus(postId) {\nupdatePostLikeStatus(postId, 2);\n}\nand in the component/posts.js,\nimport { togglePostLikeStatus } from '@/actions/posts';\n\n<form\naction={togglePostLikeStatus.bind(null, post.id)}\nclassName={post.isLiked ? 'liked' : ''}\n>\n<LikeButton />\n</form>;\nwe see the changed status if we refresh the page. To make it work on click, on the actions file,\nimport { revalidatePath } from 'next/cache';\n\nexport async function togglePostLikeStatus(postId) {\nawait updatePostLikeStatus(postId, 2);\nrevalidatePath('/feed');\n}\nnow, the status of likes changed.Another option is:revalidatePath('/', 'layout'); means, all pages wrapped by the layout should refresh.","optimistic-update#Optimistic update":"We update the new state immediately, and then do the update behind the scenes.\nimport { useOptimistic } from 'react';\n\nexport default function Posts({ posts }) {\n// hook takes data, and a function triggered by react upon getting back the data\nconst [optimisticPosts, updateOptimisticPosts] = useOptimistic(\nposts,\n(prevPosts, updatedPostId) => {\n// find the index first\nconst updatedPostIndex = prevPosts.findIndex(\n(post) => post.id === updatedPostId\n);\n\nif (updatedPostIndex === -1) {\nreturn prevPosts;\n}\nconst updatedPost = { ...prevPosts[updatedPostIndex] };\n// we don't use this here, but still.\nupdatedPost.likes = updatedPost.likes + (updatedPost.isLiked ? -1 : 1);\nupdatedPost.isLiked = !updatedPost.isLiked;\nconst newPosts = [...prevPosts];\nnewPosts[updatedPostIndex] = updatedPost;\nreturn newPosts;\n}\n);\n\nif (!optimisticPosts || optimisticPosts.length === 0) {\nreturn <p>There are no posts yet. Maybe start sharing some?</p>;\n}\n\n// if we use async, next allows using functions as client actions without 'use server' directive\nasync function updatePost(postId) {\nupdateOptimisticPosts(postId);\nawait togglePostLikeStatus(postId);\n}\n\nreturn (\n<ul className=\"posts\">\n{optimisticPosts.map((post) => (\n<li key={post.id}>\n<Post post={post} action={updatePost} />\n</li>\n))}\n</ul>\n);\n}\nand then, within the Post component, we pass the action\n'use client';\n\nfunction Post({ post, action }) {\nreturn (\n<article className=\"post\">\n<div className=\"post-image\">\n<img src={post.image} alt={post.title} />\n</div>\n<div className=\"post-content\">\n<header>\n<div>\n<h2>{post.title}</h2>\n<p>\nShared by {post.userFirstName} on{' '}\n<time dateTime={post.createdAt}>\n{formatDate(post.createdAt)}\n</time>\n</p>\n</div>\n<form\naction={action.bind(null, post.id)}\nclassName={post.isLiked ? 'liked' : ''}\n>\n<LikeButton />\n</form>\n</header>\n<p>{post.content}</p>\n</div>\n</article>\n);\n}","caching-differences-in-prod-vs-dev#Caching differences in Prod Vs Dev":"npm run build gives a .next folder. To run on prod mode, npm start.If we add a new post, the new entry won't be there as next does caching. Since pages are cached and pre rendered, it never gets re-generated again.\nWe need to tell next to revalidatePathrevalidatePath('/', 'layout')We should also do the same on createPost action.\n'use server';\n\nimport { uploadImage } from '@/lib/cloudinary';\nimport { storePost, updatePostLikeStatus } from '@/lib/posts';\nimport { revalidatePath } from 'next/cache';\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(prevState, formData) {\n...\n\nawait storePost({\nimageUrl,\ntitle,\ncontent,\nuserId: 1,\n});\nrevalidatePath('/', 'layout');\nredirect('/feed');\n}\n\nexport async function togglePostLikeStatus(postId) {\nawait updatePostLikeStatus(postId, 2);\nrevalidatePath('/', 'layout');\n}\nand then rebuild and start the server."}},"/caching":{"title":"Understand & configure caching","data":{"":"","understand-and-configure-caching#Understand and configure caching":"Request memoization: Next stores data requests with same configuration to avoid duplicate data fecthes. Cache only persists during request duration\nData cache: Stores & reuses fecthed data until it is revalidated. This is to avoid unnecessary requests to data source & speeds up application. Data cache persists until it is revalidated.\nFull route cache: Stores the rendered HTML & RSC at build time. Avoids unnecessary HTML render cycles & data fetches.\nRouter cache: managed on client side. Next stores the RSC payload in memory in browser. Ensures fast page transitions since no server request is needed.\n\nIn code, we have 2 different request from 2 different areas.\n// layout.js\nconst response = await fetch('http://localhost:8080/messages', {\nheaders: {\n'X-ID': 'layout',\n},\n});\n\n// page.js\nconst response = await fetch('http://localhost:8080/messages', {\nheaders: {\n'X-ID': 'page',\n},\n});\nWe have same data source, but we got 2 logs on server, as the configurations are different.If we get rid of the configuration, then only 1 new request will be added.\nIf we reload, no new requests will be sent. That is request memoization in action.Even if we reload the page, or navigate back and forth, no new logs will be seen. That's because of the data cache. We could call revalidatePath() to throw away the cache, or we can configure fetch function.As a config object to fetch, pass { cache: 'no-store'}. When this request hits server, it says, this specific request should not be cached.\nconst response = await fetch('http://localhost:8080/messages', {\ncache: 'no-store',\n});\nWe can also use { next: { revalidate: 5 }}. So reuse for 5 seconds and then send new data. Within 5 seconds, if there are requests sent, it will serve the cached response.\nconst response = await fetch('http://localhost:8080/messages', {\nnext: {\nrevalidate: 5,\n},\n});","controlling-data-caching#Controlling data caching":"To set on a file wide basis, give the exact name as revalidate\n// property name has to be exact\n// export const revalidate = 5;\nexport const dynamic = 'force-dynamic'; // same as setting { cache: 'no-store'}\n\nexport default async function MessagesPage() {\nconst response = await fetch('http://localhost:8080/messages');\n...\n\nreturn <Messages messages={messages} />;\n}\nWith dynamic set to force-dynamic, always refetch all the data needed anywhere in the file.Another option to make sure data isn't cached which is recommended over the other two above is:\nimport { unstable_noStore } from 'next/cache';\n\nexport default async function MessagesPage() {\nunstable_noStore();\n...\n\nreturn <Messages messages={messages} />;\n}\nwith this, if we have multiple components in the same page, and needs caching in some, but doesnt need in some, we can use this.","full-route-cache#Full route cache:":"It's created and initialized at build time. If we build the app, next pre renders all the pages unless they are dynamic pages.\nWhen we start the app, its the pre rendered page that is getting served.If we set atleast one of the setting, either dynamic or revalidate, then the page auto disables full route cache.We can also use revalidatePath.\nrevalidatePath() - we revalidate some piece of cache on demand when we tell next js to do it.\nrevalidateTag('msg') - we can assign tags to requests.\n\n\nconst response = await fetch('http://localhost:8080/messages', {\nnext: {\ntags: ['msg'],\n},\n});\nWhen revalidate the tags, any request that use the same tags will be revalidated.","set-request-memoization-for-custom-data-source#Set request memoization for custom data source":"// custom data source\nimport { getMessages } from '@/lib/messages';\n\nexport default async function MessagesPage() {\nconst messages = getMessages();\n\nif (!messages || messages.length === 0) {\nreturn <p>No messages found</p>;\n}\n\nreturn <Messages messages={messages} />;\n}\nto add request de-duplication for our own data fecthing code,\nimport { cache } from 'react';\n\nexport const getMessages = cache(function getMessages() {\nconsole.log('Fetching messages from db');\nreturn db.prepare('SELECT * FROM messages').all();\n});\nThen, it is just one request per page reload, even though there are multiple places where we use the getMessages function.\nThe request is cached. React cahces the returned data. Then that response is reused everywhere.","data-cache-functionality-for-our-own-data-source#Data cache functionality for our own data source":"import { unstable_cache } from 'next/cache';\n\nexport const getMessages = unstable_cache(\ncache(\nfunction getMessages() {\nconsole.log('Fetching messages from db');\nreturn db.prepare('SELECT * FROM messages').all();\n},\n['messages'], // optional\n{\nrevalidate: 5,\ntags: ['msgs'],\n}\n)\n);\n\n// and in component\nto tell that the data cached is changed, we can use revalidatePath, or revalidateTag."}},"/optimization":{"title":"Optimizations","data":{"":"Image optimizations, SEO metadata,\n\nIf the image is part of the codebase and is available in file system.\nimport Image from 'next/image';\nimport logo from '@/assets/logo.png';\n\n<Image\nsrc={logo}\nalt=\"alt text\"\nwidth={300}\nheight={300}\nsizes=\"10vw\"\npriority\n/>;\n\nHere, logo is an object with src, height, width, and other details. loading=\"lazy\" is added automatically.\nHelps with layout shifting\nsrcset helps loading different images for various viewport sizes.\npriority preloads the image as it should be always loaded.\n\nFor user generated images,\n// to closest container\n.post-image {\nposition: relative;\nwidth: 8rem;\nheight: 6rem;\n}\n\n<div className=\"post-image\">\n<Image fill alt={}/>\n</div>\n\n// in next.config.js\nconst nextConfig = {\nimages: {\nremotePatterns: [{ hostname: 'res.cloudinary.com' }],\n},\n};","image-loader-and-cloudinary-resizing#Image loader and cloudinary resizing":"function imageLoader(config){\nconst urlStart = config.src.split(\"upload/\")[0];\nconst urlend = config.src.split(\"upload/\")[1];\nconst transform = `w_200,q_${config.quality}`\nreturn `${urlStart}upload/${transform}/${urlEnd}`\n}\n<div className=\"post-image\">\n<Image loader={imageLoader} fill alt={} src={post.image} quality={50}/>\n</div>","page-metadata#Page metadata":"// in page.js\n\nexport const metadata = {\ntitle: '',\ndescription: '',\n};\n\n// for dynamic metadata\nexport async function generateMetadata({ params }) {\nconst posts = await getPosts();\nconst numberOfPosts = posts.length;\nreturn {\ntitle: '',\ndescription: 'Browse all' + numberOfPosts + ' of our posts',\n};\n}","layout-metadata#Layout metadata":"We can add the same in layouts too. It will be the default one for all pages."}},"/authentication":{"title":"Authentication","data":{"":"","user-signup#User signup":"To create a user\n// lib/user.js\nimport db from './db';\n\nexport function createUser(email, password) {\nconst result = db\n.prepare('INSERT INTO users (email, password) VALUES (?, ?)')\n.run(email, password);\nreturn result.lastInsertRowid;\n}\nWhen creating a user, his passwords need to be hashed, so\n// lib/hash.js\nimport crypto from 'node:crypto';\n\nexport function hashUserPassword(password) {\nconst salt = crypto.randomBytes(16).toString('hex');\n\nconst hashedPassword = crypto.scryptSync(password, salt, 64);\nreturn hashedPassword.toString('hex') + ':' + salt;\n}\n\nexport function verifyPassword(storedPassword, suppliedPassword) {\nconst [hashedPassword, salt] = storedPassword.split(':');\nconst hashedPasswordBuf = Buffer.from(hashedPassword, 'hex');\nconst suppliedPasswordBuf = crypto.scryptSync(suppliedPassword, salt, 64);\nreturn crypto.timingSafeEqual(hashedPasswordBuf, suppliedPasswordBuf);\n}\nNeed an action to handle the interaction\n// actions/auth-actions.js\n\n'use server';\n\nimport { hashUserPassword } from '@/lib/hash';\nimport { createUser } from '@/lib/user';\nimport { redirect } from 'next/navigation';\n\nexport async function signUp(prevState, formData) {\nconst email = formData.get('email');\nconst password = formData.get('password');\n// validate\nlet errors = {};\nif (!email.includes('@')) {\nerrors.email = 'Email is invalid';\n}\nif (password.trim().length < 8) {\nerrors.password = 'Password is invalid';\n}\n\nif (Object.keys(errors).length > 0) {\nreturn {\nerrors,\n};\n}\n\nconst hashedPassword = hashUserPassword(password);\n\ntry {\ncreateUser(email, hashedPassword);\n} catch (error) {\nif (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\nreturn {\nerrors: {\nemail: 'Email already exists',\n},\n};\n}\nthrow error;\n}\nredirect('/training');\n}\nand in the component, we use the action\n'use client';\nimport { signUp } from '@/actions/auth-actions';\nimport Link from 'next/link';\nimport { useFormState } from 'react-dom';\n\nexport default function AuthForm() {\nconst [formState, formAction] = useFormState(signUp, {});\nreturn (\n<form id=\"auth-form\" action={formAction}>\n<input type=\"email\" name=\"email\" id=\"email\" />\n<input type=\"password\" name=\"password\" id=\"password\" />\n{formState.errors && (\n<ul id=\"form-errors\">\n{Object.keys(formState.errors).map((err) => (\n<li key={err}>{formState.errors[err]}</li>\n))}\n</ul>\n)}\n<button type=\"submit\">Create Account</button>\n<p>\n<Link href=\"/\">Login with existing account.</Link>\n</p>\n</form>\n);\n}","third-party-library#Third party library":"Lucia. Wec an use it in next, node etc\nNextAuth doesnt work well with router.\n\nnpm i lucia @lucia-auth/adapter-sqlitein lib/auth.js\nimport { Lucia } from 'lucia';\n\nimport { BetterSqlite3Adapter } from '@lucia-auth/adapter-sqlite';\nimport db from './db';\nimport { cookies } from 'next/headers';\nconst adapter = new BetterSqlite3Adapter(db, {\nuser: 'users',\nsession: 'sessions',\n});\nconst lucia = new Lucia(adapter, {\nsessionCookie: {\nexpires: false,\nattributes: {\nsecure: process.env.NODE_ENV === 'production',\n},\n},\n});\n\nexport async function createAuthSession(userId) {\nconst session = await lucia.createSession(userId, {});\nconst sessionCookie = lucia.createSessionCookie(session.id);\ncookies().set(\nsessionCookie.name,\nsessionCookie.value,\nsessionCookie.attributes\n);\n}\nand in the actions,\n'use server';\n\nimport { createAuthSession } from '@/lib/auth';\nimport { hashUserPassword } from '@/lib/hash';\nimport { createUser } from '@/lib/user';\nimport { redirect } from 'next/navigation';\n\nexport async function signUp(prevState, formData) {\nconst email = formData.get('email');\nconst password = formData.get('password');\n// validate\nlet errors = {};\nif (!email.includes('@')) {\nerrors.email = 'Email is invalid';\n}\nif (password.trim().length < 8) {\nerrors.password = 'Password is invalid';\n}\n\nif (Object.keys(errors).length > 0) {\nreturn {\nerrors,\n};\n}\n\nconst hashedPassword = hashUserPassword(password);\n\ntry {\nconst id = createUser(email, hashedPassword);\nawait createAuthSession(id);\nredirect('/training');\n} catch (error) {\nif (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\nreturn {\nerrors: {\nemail: 'Email already exists',\n},\n};\n}\nthrow error;\n}\n}\nWith that, if we provide credentials, and click create account, it shoudl redirect to the training route.\nInspect and find the cookie in browser. Application > Cookies > Select the localhost > auth_sessionAuth cookie is automatically added.","verify-an-active-auth-session#Verify an active auth session":"export async function verifyAuth() {\nconst sessionCookie = cookies().get(lucia.sessionCookieName);\nif (!sessionCookie) {\nreturn {\nuser: null,\nsession: null,\n};\n}\nconst sessionId = sessionCookie.value;\nif (!sessionId) {\nreturn {\nuser: null,\nsession: null,\n};\n}\nconst result = await lucia.validateSession(sessionId);\ntry {\nif (result.session && result.session.fresh) {\nconst sessionCookie = lucia.createSessionCookie(result.session.id);\ncookies().set(\nsessionCookie.name,\nsessionCookie.value,\nsessionCookie.attributes\n);\n}\nif (!result.session) {\nconst sessionCookie = lucia.createBlankSessionCookie();\ncookies().set(\nsessionCookie.name,\nsessionCookie.value,\nsessionCookie.attributes\n);\n}\n} catch (error) {}\n\nreturn result;\n}\nand in the component, we check for the session\nimport { verifyAuth } from '@/lib/auth';\nimport { getTrainings } from '@/lib/training';\nimport { redirect } from 'next/navigation';\n\nexport default async function TrainingPage() {\nconst result = await verifyAuth();\nif (!result.user) {\nreturn redirect('/');\n}\nconst trainingSessions = getTrainings();\n}","switch-auth-modes#Switch auth modes":"If we redirect the user to login using a query param\n<Link href=\"/?mode=login\">Login with existing account.</Link>\nwe can access them at the app/page.js\nexport default async function Home({ searchParams }) {\nconst formMode = searchParams.mode || 'login';\nreturn <AuthForm mode={formMode} />;\n}\nand in the auth form component\n'use client';\nimport { signUp } from '@/actions/auth-actions';\nimport Link from 'next/link';\nimport { useFormState } from 'react-dom';\n\nexport default function AuthForm({ mode }) {\n...\nreturn (\n<form id=\"auth-form\" action={formAction}>\n...\n<p>\n<button type=\"submit\">\n{mode === 'login' ? 'Login' : 'Create account'}\n</button>\n</p>\n<p>\n{mode === 'login' && (\n<Link href=\"/?mode=signup\">Create an account.</Link>\n)}\n{mode === 'signup' && (\n<Link href=\"/?mode=login\">Login to the account.</Link>\n)}\n</p>\n</form>\n);\n}\nin lib/user.js\nexport function getUserByEmail(email) {\nconst result = db.prepare('SELECT * FROM users WHERE email = ?').get(email);\nreturn result;\n}\nand in auth action\nexport async function login(prevState, formData) {\nconst email = formData.get('email');\nconst password = formData.get('password');\nconst exitingUser = getUserByEmail(email);\nif (!exitingUser) {\nreturn {\nerrors: {\nemail: 'Cannot authenticate',\n},\n};\n}\nconst isValidPassword = verifyPassword(exitingUser.password, password);\nif (!isValidPassword) {\nreturn {\nerrors: {\npassword: 'Cannot authenticate password',\n},\n};\n}\n\nawait createAuthSession(exitingUser.id);\nredirect('/training');\n}\n\nexport async function auth(mode, prevState, formData) {\nif (mode === 'login') {\nreturn login(prevState, formData);\n}\nreturn signUp(prevState, formData);\n}\nand in auth form,\nexport default function AuthForm({ mode }) {\nconst [formState, formAction] = useFormState(auth.bind(null, mode), {});\n}","add-auth-only-layout#Add auth only layout":"app/\n(auth)/\ntraining/\nlayout.js\nand in the new layout,\nimport '../globals.css';\n\nexport const metadata = {\ntitle: 'Next Auth',\ndescription: 'Next.js Authentication',\n};\n\nexport default function AuthRootLayout({ children }) {\nreturn (\n<>\n<header id=\"auth-header\">\n<p> Welcome</p>\n<form>\n<button> Logout </button>\n</form>\n</header>\n{children}\n</>\n);\n}","logout#Logout":"In lib/auth.js\nexport async function destroySession() {\nconst { session } = await verifyAuth();\nif (!session) {\nreturn {\nerror: 'Unauthorized',\n};\n}\nawait lucia.invalidateSession(session.id);\nconst sessionCookie = lucia.createBlankSessionCookie();\ncookies().set(\nsessionCookie.name,\nsessionCookie.value,\nsessionCookie.attributes\n);\n}"}}}